
KAT: Hi! Thank you! Yeah. I'm Kat. It's great to be here. Today I'm mostly gonna be talking to you about something called certificate transparency. So... Yeah. Before we get on to what certificate transparency itself is, I want to sort of start off by talking a little bit about... Oh, wait. How do I get it to change? Hold on a second. There we go. I want to start off by talking a little bit about the problem that certificate transparency was intended to help with when it was dreamed up. So I want to start with an example. This is where I have to put my hands up and say: I do work at Google. The example was a Google example. It was the only way I could get my slides approved. Please bear with it. We're gonna start off. Say you are a Gmail user and you want to log into your email. What are you gonna do? Go to mail.Google.com, hit enter, type in your login details, and a web page is going to appear that probably looks something like this. The more observant of you are going to notice that in the top left corner the beginning of the URL has gone green and there's this very reassuring little padlock symbol and the word secure. This means you have connected to the Google mail service securely and everything is encrypted, so anyone listening in on the conversation can't tell what's being said. So great. You've got this secure connection. Yay. But how do you know that it's actually Google that you're talking to on the other end of this conversation?

How do you know that it's not just somebody pretending to be Google? How can you be sure that when you type in your login details, you're not actually sending them to an impersonator? This is where we start talking about certificates. A certificate is a thing that a web browser... Sorry. That a web server sends to a web client to prove that they are who they say they are. A certificate contains two things. It contains a public key and it contains a domain name or a web address. And what a certificate means is that if you use this public key to set up a secure connection, you can be sure that you're talking to the real version of this web address. Now, for a certificate to be accepted by a browser, the certificate has to be signed by one of these trusted entities that we call Certificate Authorities or CAs. So going back to our example, you know, say you're Google and you've got this website, mail.Google.com, that you want your users to be able to connect to securely.

You're gonna need a certificate to be able to present to your users when they try to connect. So you go along to a Certificate Authority and you say: Hi. I'm Google. I've got this website, mail.Google.com. And here's my public key. Please can you issue a certificate to me? The certificate authority will take this information, they'll take a look at it, and they'll run a bunch of checks to convince itself that first of all this is actually Google it's talking to, and that all of the information provided is both correct and truthful. And if the CA is happy with this information, it'll sign a certificate, issue the certificate, and send it back to Google for them to use. Now, this is the point in Web PKI where there's trust. We trust the Certificate Authorities to get this right. We trust CAs not to issue certificates to the wrong people. Okay. So now... You know, you're on your browser. You're trying to check your email.

When you go to mail.Google.com, Google will then respond with this certificate. It will send through the certificate that it's had issued. Your browser will check the certificate and see it's been signed by a trusted certificate authority and set up a secure connection so that you can then check your email. Okay. So that's all fine. That's sort of how the system was intended to work. But then what happens if a bad guy comes along and says... Goes to the Certificate Authority and says: Hi. I'm Google. I've got this website, mail.Google.com. Here's my public key. Please can you issue a certificate for me? Like I said, we trust certificate authorities to do the right thing here. We trust CAs not to issue certificates to the wrong people.

We trust CAs to be able to tell that this isn't actually Google they're speaking to and not to sign anything. But what if for whatever reason... Say maybe the CA is hacked or they make a mistake... Say they issue a certificate that they shouldn't. Well, then when you go to connect to mail.Google.com, the attacker could respond with their certificate instead. And your browser has no way of telling that this is a fraudulent certificate. It's still signed by a trusted Certificate Authority. So your browser will set up a secure connection. But this time, when you send your login details, you'll actually be sending them to an attacker. Okay. So this sounds bad, right? Okay. This isn't great. But is it something that really happens? Is this really something we have to worry about?

Unfortunately, it is. There are a number of examples that I could have used here. The one I've chosen is the one that was one of the real sort of inspiring incidents that sort of set off certificate transparency. So it's one of the more relevant ones to us. Back in 2011 there was a Certificate Authority called DigiNotar, and what happened is they were hacked. And the attackers managed to issue a wild card Google.com certificate. So what happened is DigiNotar apparently detected the breach when it happened, but being hacked was bad for business, so they decided not to tell everyone. They thought they had contained it. It was actually three months later that a user noticed this fraudulent certificate floating around and being used, and reported it back. And after some investigation, it turned out that the attackers had actually got hold of not just one, but something like 500 fraudulent certificates for a number of big name domains.

And yeah. Well... DigiNotar is no longer a CA. Let's put it that way. So okay. There's clearly a problem here. The problem is this blind trust we have in CAs to just do the right thing and not misissue certificates. But what this example really shows is that the problem is actually more than that. It's if a CA does misissue a certificate, we have no way of telling that that's happened without them sort of owning up and saying: Look, we did this. And there's actually no guarantee that they actually know this has happened. So what can we do about that? Well, this is where I bring up certificate transparency. Enter certificate transparency. It's a system to detect certificate misissuance. We're not preventing certificate misissuance. That's a harder problem. Within certificate transparency, there's this core concept, an idea of a certificate transparency log. And that is a publicly auditable, append only store. It's a public repository of certificates, that anyone can access, anyone can add to, anyone can go and see what's in there. There are certificate transparency logs already in existence. And they can be run by anyone with the technical capacity to sort of keep them up and running.

Currently they're mostly run by large tech companies and Certificate Authorities. But really they can be run by anyone who has a sort of vested interest in the security of the internet. In fact, there was actually a guy who we met up with, who was super enthusiastic about certificate transparency, and he said: Yeah, I'm running a CT log called behind the sofa! It was literally running on a box behind his sofa. So anyone can do it. How reliable they are, that's another question. So the goal is to get the certificates that are used on the web into certificate transparency logs. They're publicly auditable, so you can monitor them and keep an eye out on certificates for your domain, and if you see a certificate for your domain that you didn't ask for or doesn't contain your public key, you can take the necessary steps to get it revoked. So before we had this system where CAs were just blindly trusted not to misissue certificates.

Now we have a system where certificate transparency logs will publicly publish all the certificates that Certificate Authorities are issuing. But what if a certificate transparency log lies about what's in it? What if a CT log says it's going to store and publish a certificate and actually doesn't? What if a CT log does store and publish a certificate for a short amount of time but then deletes it and stops publishing it? Haven't we just moved the trust from CAs to certificate transparency logs? No. It actually turns out we can verify that certificate transparency logs are behaving correctly. And the reason we can do that is because of the cryptographic data structure that is used by certificate transparency logs to store certificates. And that data structure is a Merkel tree. Now, the Merkel tree that you can see up on the screen is just one containing seven certificates. So this represents a CT log containing seven certificates. Very, very small. And what a Merkle tree is -- it's very simple. It's just a binary tree. Where the leaves are the hashes of the things that are containing it.

In our case, the certificates. If you look at the slide, A is the hash of certificate one. B is the hash of certificate two. C is the hash of certificate three, et cetera. And the intermediate nodes of the tree are the hash of the concatenation of the two children of that node. So again, if you look at the slide to just, like, get your head around that, G is the hash of A concatenated with B. And then K is the hash of G concatenated with H. And that trickles all the way up to the top, where you get the root of the tree, or what we call the tree head. Now, upon request, certificate transparency logs are required to publish these tree heads. And those published tree heads in conjunction with this data structure means that we can actually prove and we can check -- like, cryptographically check -- that certificate transparency logs are behaving. So one example that I mentioned of dodgy things that a CT log could do is: What if a CT log accepts a certificate, says I'm gonna add it, I'm gonna publish it, and then actually doesn't? If we take that example -- okay, what if we wanted to be able to check -- we submitted certificate three to a certificate transparency log and we want to be able to check that C3 has actually been included in the log. How can we do that? We know C is just the hash of C3, so we can calculate C.

If we can calculate H and then calculate K and then calculate the tree head, we can compare the tree head with the tree head that the log is reporting. And if they're the same, we know the log is behaving. It's incorporated our certificate into its tree. Wonderful. But in order to get H, we need D. And in order to calculate K, we need G. And in order to calculate the tree head, we need L. So in order for a CT log to prove that it has included a certificate, all it has to do is provide those three intermediate nodes. Now, as a CT log grows, as more certificates are added to it, this internal Merkle tree is going to grow as well. So the tree head, the root of the tree, is going to change. The value of it is going to change. And so there's a second proof mechanism that's similar to this one, but a bit more complicated, that I'm not gonna go over right now, for time, that proves that given two of these tree heads, it proves that they're consistent.

And what I mean by consistent is that the sort of larger of the two tree heads was obtained only by appending -- only by adding certificates to the previous tree head. So I mentioned that previous CT logs were meant to be append-only. This is how you can check it. Given two tree heads with associated tree sizes. And those two proof techniques are all you need to be able to check to make sure that a certificate transparency log is working correctly. Does it work? Yes, it does. The certificate transparency wider ecosystem has successfully detected a number of misbehaving certificate transparency logs, using these mechanisms. One of the logs -- what happened here was they used the same public key to run both a production and a test log. In the certificate transparency world, CT logs are identified based on their public key. So by using the same key for two logs, any tree heads issued by either of those logs were considered to be from a single log. What happened in this case is their production log issued a tree head, their test log issued a tree head for a different set of certificates, because it contained a different set of certificates, and when asked, the production log couldn't produce one of these consistency proofs between these two tree heads, and that was when we started figuring out something funny was going on.

In the second instance, this log was actually running on, I believe, on Amazon... The AWS S3... It was running on S3 when the outage happened, towards the beginning of last year. And what happened here was they issued a tree head, and then S3 went down, and in the panic of oh, no, all our data, everything is down, they restored from an older back-up that didn't contain all of the certificates. And a bunch of new certificates came in and were added to this older version of the tree and they issued another tree head, and those two tree heads were then inconsistent because there were certificates missing from the second one that were in the first one. In this case, although they messed up, the tree became inconsistent, it was really, really impressive how the log operators dealt with it. The inconsistent tree head was only being reported for something like two minutes, and the log operators very, very quickly produced a very detailed postmortem of everything that had gone wrong. And there was a lot of public discussion on everything that had happened here.

So just the way that they dealt with this, this sort of failure, was absolutely fantastic. And one of the things with certificate transparency is that we sort of pride ourselves on being transparent. So whenever something does go wrong, all of the discussion does happen in public, because CT is still quite new. It's still quite young. We're still learning. And so every single one of these war stories, although something did go wrong, we learned something from it. And something good came from it, and we learned how not to mess up in the future. So... Pros and cons. Okay. So... Sorry. Certificate transparency sounds like a great idea, right? I'm biased, but yay. How do we actually incentivize people to use these logs? To put certificates into certificate transparency logs? Why would they do that except for the good of the internet? The answer to that is browsers. Back in April, Chrome started requiring that all newly issued certificates have to be present within multiple trusted certificate transparency logs to be accepted.

Safari currently requires this for a specific subset of certificates. So Safari requires this for extended validation or EV certificates. And EV certificates are basically the ones that make your URL bar look like this. Yeah. But as of October this year, Safari will require that all newly issued certificates will be present in multiple trusted certificate transparency logs to be trusted. So certificate transparency is basically becoming part of the Web PKI. There have been other discussions with the other major browser vendors about supporting certificate transparency too. So that's great. Now, I've mentioned a couple of times... Okay. On the previous slide, we had... These certificates had to be present in trusted certificate transparency logs. What do we mean by trusted? I said... You don't have to trust them. So what does that mean? And what trusted really means is that certificate transparency logs are... CT logs that are behaving correctly. Now, Chrome specifically has a log policy.

That dictates what its perception of behaving correctly is. And it includes things like conforming to the certificate transparency RFC, maintaining 99% uptime, so that you can access it to actually monitor and check for domains. And there's a handful of other things in there. But one particular one is that when a certificate is submitted to a log, it has to be... The log has to incorporate it into its Merkle tree within 24 hours. Now, the point of this requirement is that... Is to sort of minimize the amount of time that it takes... The amount of time between when a certificate is submitted to a log and when it's then publicly accessible for monitoring. But then at the same time, it's trying to balance that with operationally allowing enough time to incorporate the certificate into this Merkle tree structure.

Now, within 24 hours... Quite a long time, right? How long can it take to actually add a certificate to a Merkle tree? That doesn't sound that hard. But in reality, what this 24 hours is -- is the amount of time that a log operator has to recover or to handle things when something goes wrong with the log. And we saw from the Amazon S3 outage war story that with certificate transparency logs, recovering from failure isn't as simple as restoring from a backup. Usually there's some sort of manual intervention needed. And trust me, if the thing that goes wrong is at 3:00 am on a Sunday, your log maintaining team are gonna be really thankful they have 24 hours to handle it.

That being said, 24 hours is not long enough for all logs. So... One log did actually manage to incorporate a certificate into its tree within 24 hours. But it was actually having problems with the external APIs, so although it was sort of technically in the tree within 24 hours, the certificate wasn't publicly accessible until 36 hours after being submitted. So that was technically counted as going against the sort of behavior of the log policy. Another log, which was actually one of our logs, simply failed to incorporate certificates within 24 hours. It turns out it's not that long after all. No, what happened in this instance was: A specific person -- who we are good friends with now -- from the University of Michigan came across... So they have been accumulating a large corpus of certificates themselves, and they realized a large number of them -- talking about 6 million of them -- weren't present in... Well, in any certificate transparency logs. And they thought... Oh, these guys, the goal is to get all of the certificates used on the web into these logs. Let's help them out. Let's help them achieve their goal by submitting these to our logs. And they submitted all 6 million of them at once!

Pretty safe to say this was the largest load test we have had to date. And yeah. So what this resulted in was this huge backlog of certificates to be sequenced and then stored, and because of the sort of... The level of consistency required, when storing certificates, in certificate transparency logs, 24 hours later, this was still chugging along. Some of the certificates hadn't been incorporated. So that was the end of that. But most logs don't have a problem with this 24-hour limit and are still very happily pottering along. Okay. Big question. Does certificate transparency actually work? I like to think I wouldn't go around giving talks like this about it if we had built the system and it was kind of failing at life, so... Yes. It does. Proof that it works. So we run a monitor for all of the certificate transparency logs that are out there, for Google-owned domains. And we discovered that a specific Certificate Authority had issued a certificate for www.Google.com that we hadn't asked for. Now, we went and spoke to this CA, and it turns out they... One of their test engineers needed a certificate for testing. And they were like... Oh, I need a domain for my certificate. What shall I use? Oh, I know. www.Google.com. No! Bad!

Do not issue certificates for domains you don't own! Not okay! So while it was a testing certificate, so it was only actually valid for something like two days, so the risk was much lower, they did say... They were like... No, it's okay, it's okay. It never left our test environment. We found this in the Google certificate transparency log. Like... Yes, it did. Yes, it did. You're wrong. Anyway, they are no longer a CA. Another example of the benefit of certificate transparency is something that was in a Facebook blog post. So Facebook also run a CT monitor for Facebook-owned domains, I assume. While this wasn't malicious thing, the benefit they got was one of their internal teams had used a CA to issue certificates that wasn't one of their, like, accepted CA vendors.

And so the CT helped them detect that and get the certificate revoked and reissued by an accepted CA. So got a thumbs up from them, which is always nice. A blog post. If you want to know more. Okay. So... Before I can tell you sort of what the current state and what sort of... Like, in the near future for CT, I need to start out by just saying how things started. Going back. In the beginning. In the beginning, we wanted to... We had this idea for CT, and we wanted to show that it was possible to run reliable certificate transparency logs. Because we wanted to convince everyone to adopt this new idea, and so we needed to show to them that it can be done. And so initial implementation of CT logs was designed to be extremely reliable and extremely robust to infrastructure failure. And what that resulted in was a design that essentially stored the entire Merkle tree in memory. And that was kind of fine, back when logs were maybe a couple of million certificates.

But recently everyone is switching to HTTPS, which is great, and there's sort of rising popularity of much shorter-lived certificates, which is also great, but that does mean that there are a lot more certificates out there. A big shoutout to Let's Encrypt at this point. And yeah. So the current largest certificate transparency log is now sitting at about 400,000 certificates. Not so feasible to store in memory. So what this led to -- we saw this coming. It wasn't like now, argh, what are we gonna do? Me and a bunch of guys that I work with have developed this thing called Trillian. And what Trillian is -- is a scalable Merkle tree implementation. And we use this to back our certificate transparency logs. The difference with Trillian are that they're stored in a database instead of being stored in memory. It's Open Source. So you can go and check it out, if you're interested. We've tested it in a bunch of different ways, and we've seen that it can take roughly 2,000 QPS. Heading up towards its top limit.

So potentially up to 2,000 certificates being submitted per second. That's quite a lot, right? We've tested it -- we tested the size of it. Obviously size was an issue. 400 million certificates seemed like a lot. This has been tested to -- for a single log, 13 billion certificates. So that's way in the future. Trillian is actually multitenanted, which means that one Trillian instance can contain multiple Merkle trees. There are a few different benefits with that. The main one being: For each new log you want to spin up, you don't have to go through all of the setup process for that log. In one Trillian instance, you can put one log in there, and it's much simpler and faster. There's an ease thing. With the multitenancy, we have tested it to the point where... Well, it says on the slide. You can read it. We've got ten tenants, and shared between those ten tenants, there are 42 billion entries. More big entries. That's fun. One of the key things with Trillian is it's not specific to certificates.

So it's more of a general transparency concept. It's just the Merkle tree implementation. You can give it blobs of whatever and it will store them. And this is kind of great. Because it gives you all those potential... All those verifiable properties with the two proofs that I mentioned, potentially for other applications. And Trillian provides both the log mode and what we call a verifiable map mode. Which is essentially a verifiable key-value store. The way that is from a Merkle tree point of view -- this is a Merkle tree with 2 to the 256 leaves, most of which are empty, so it's doable. And if you want to add a key-value pair to the Merkle tree, you use the hash of the key to find which leaf to store it in, and that's where you putted the value. This is sort of great, because then you can use these two proof mechanisms that Merkle trees provide, again, for a key-value store, to prove either existence or non-existence of specific values, which is quite fun. And has a use that I'm gonna mention in a minute.

Okay, so Trillian -- I mentioned it's not just for certificates. It can be used sort of for wider things as well. It is used for certificates. That's one thing. We're using it to back CT logs. A number of other... I think a couple of CAs are also using it to back their CT logs, which is great. It's being used at the moment for something called key transparency. Key transparency actually uses both modes. It uses the log mode and the map mode, and the goal... Well, the idea with key transparency is to target secure end to end messaging. So that's fun! It's also being used by Deep Mind, who are using it to... Deep Mind is doing a lot of work at the moment with NHS health data. You may have read about it in the news. Obviously health data is very sensitive, and people accessing health data when they shouldn't be is bad. So Deep Mind are going to be using Trillian to keep a sort of verifiable log of all the data accesses that they have. So then if someone does access the data in a way that they shouldn't, at least they'll know, because they can't go back and tamper with the access log. And then there have been a number of other sort of ideas for what to do with Trillian that have been floated. Some chat about binary transparency, there have been discussions about firmware transparency. There was some discussion in the early days of Trillian, with the UK government, about using it to help prove the integrity of a bunch of the registers that they maintain. Things like the register of countries, register of land that the Land Registry keeps, there's also apparently a registry of all the cows in the UK. Which was news to me.

This actually made me laugh a little bit, because I believe a few years ago someone was telling me about the old school, like, tech interview questions. That were really abstract. Like oh yeah, if you had to calculate how many cows there were in the UK, how would you do it? There's a register! That's how I would do it! And so if any of you guys have any more sort of ideas for uses of Trillian or anything like that, come and chat with us. I'm here. A bunch of the guys from the team I'm on are here. We would love to talk to you about your ideas. That would be great. And that's it!

(applause)

>> Thank you very much. We've got time for really brief questions, I think. One in the middle. He was first, I think.

>> Hello. Fantastic talk. I was just wondering... So when you've got billions of things in a tree and I want to calculate whether the tree head is actually accurate, how fast is that? Because you were talking about sort of six million going in was quite slow to calculate. If I want to prove that the CT is accurate, is that something I can do?

KAT: What do you mean? Check that the whole tree is consistent?

>> I guess so. Yeah. If I've downloaded a certificate transparency log from Symantec or whatever, how hard is it to prove that...

KAT: Hard-ish. So basically currently in certificate transparency, there are a number of monitors that are doing exactly what you're saying. Downloading the whole tree and building it up, calculating every single in-between hash to check that that final hash meets the one that the log is reporting. And those monitors are very good at... If it doesn't, they will get in touch with... Well, it's all on public mailing lists. They'll say -- look. It's not. In terms of... It depends on what you want to do. It depends on what your use case is. For site owners, they maybe don't care as much about that. Other people can be checking the integrity of it. If Chrome trusts it, then I... Kind of thing. But in terms of the two proofs that I showed, so if you're... Say you're a CA and you submit a certificate to it, and then you want to check that that certificate has definitely been included, the number of nodes you need is log n, because it's a tree. So that's super quick. Verifying the whole tree can take a bit more time, but actually, the sort of challenge there is downloading the whole tree. There are sort of different things.

>> This chap and then I think other questions will have to be offline, I'm afraid.

KAT: Yeah, come and find us after. I'm happy to talk.

>> I was just wondering -- you said the tree is currently at 400 million certificates. How big is that, in terms of gigabytes?

KAT: I don't know! Does anyone... Do you guys know how big that is, in terms of gigabytes? I'm getting a... From my boss. So... We don't know. No? We haven't looked. I can look. We can look and we can tell you, if you want. Yeah.

>> Okay. Thanks very much. Let's show our appreciation.

(applause)


