>> Welcome to tent C. A couple of reminders that you've already heard everywhere else. If you're looking for an exciting career in tending a bar, you can start tonight, because we need volunteers in the bar tonight. And also amplified music has to be off by 11:00 tonight. Otherwise, we may not have EMF Camp again. Licenses and what have you. I'm pleased to say we actually have the name of the person speaking, which wasn't on the wiki. We have Rick here to talk about building a visual robot with MATLAB and Simulink.

>> Hello! My name is Rick. If you were wondering who MathWorks are, when you were looking at your badge, we are the people who do MATLAB and Simulink. You might have come across Simulink in the university or industry setting, or if you're struggling to think of where you came across the word but you have not actually come across our software, you might have been a victim of some of my late night marketing. I was a guy who was walking around with an LED do matrix. And every so often I would sneak in an advert here or there just to play people off. Okay.

What I want to do for the next 20 minutes is show you how you can use MATLAB and Simulink to build a basic demo, and pretty much just show you what advantages those two tools can give you in doing this. So let me first beginning for anyone who hasn't seen them before... What is MATLAB and Simulink? MATLAB is a mathematically-based scripting language. It was originally designed around matrix algebra. That's where the name came from. It's matter of fact laboratory. It's since bloomed out into all sorts of data analytics and other processing needs. Simulink is its sister product, and this is the tool you go to if you want to model a system over time. So, for example, the software in your car or the software on a commercial plane was likely programmed in collaboration with Simulink. Or on top of a Simulink model.

Both of these tools are available for home use. So you can purchase them for hobby projects. So that's why I want to show you one example of something you can do with these. That example is: You've got a robot, you've got a tennis ball. And the example is: The robot likes the tennis ball. It forever follows where the tennis ball goes. That's the demo. That's all it is. And what I'm gonna show you is how you're gonna get to something like this using MATLAB and Simulink. The hardware is pretty simple. It's a Raspberry Pi with a Raspberry Pi camera and a standard rover kit. So this is the version you can purchase for about 30 pounds. And the idea is pretty simple. You take the video feed that's coming from the Raspberry Pi camera, you do some analysis on that, figure out where in the robot's vision the tennis ball is, and based on that information you decide what to do -- what the two motors want to do, to get the robot to find where the tennis ball is. This is a Simulink model. This is something that you can compile and run on the Raspberry Pi or an Arduino or any other hardware that you want to target.

And what I'm gonna do is... These are the four stages of what it actually does. There's a bit more detail behind visual and a bit more detail behind controller. I'm gonna show you how to solve these two problems. So the first one is visual analysis. How do you find a tennis ball in a video feed? So if you do a Google search, you'll find a couple of algorithms. There are various different ways to cut it. But the simplest of them is: You start off with a picture of a tennis ball. In this case, I've given you two. One which is off a different kind of lighting as the other. So you bring this into MATLAB, using this snapshot function from the Raspberry Pi. You then figure out... Okay. The illumination of the top one makes the tennis ball look orange. So you want to get rid of the illumination effect if you can.

And what you're doing is: What are the yellow pixels in the image? So you convert the image to a hue, saturation, and value, and you filter out the pixels, so that what you get left are the pixels of yellow hue. And one final set, which is: Pixels aren't enough. You want get rid of detail like the lines on the tennis ball, or when you get a bad image, you only see a texture rather than a solid blob. So you do image, morphological operations. So things where each pixel is the output of some operation of the same pixel from the input, and its neighboring region. So you get to something like this, where each object is now just a solid blob, and finally you just pick out: What is the biggest, yellowest thing or the biggest, yellowest, circular thing in your vision? So this is something you can bring into MATLAB. You can figure out what are the steps you need to do to get to where the tennis ball is. You can take this code and insert it into Simulink or take this code and build the Simulink equivalent. Both are paths you can do.

What can you do with it? Well, one of the things you probably want to do is prove that it works. Separate from actually trying to get the robot to behave. So one of the things you can do is... All right. This visual analysis and the camera... These are the same blocks as from the previous model. But the right hand side, I've just inserted in: Build a diagnostic video, of what the robot sees and where it thinks things are. And stream that video from the Raspberry Pi to something which has a stream. Stream the video from the Raspberry Pi to my laptop, say, over Wi-Fi. And you get something that looks a bit like this. It sees where the ball is. This is the accumulation of all these four steps. And the Raspberry Pi can see where the tennis ball is. Suppose that this is quite well tuned. I've picked the hue values pretty nicely. Let's say I've got that wrong. I want to play around with it a little bit more.

Because this is Simulink, one of the features Simulink has is it says... While the robot is currently running, I can attach my laptop to it in such a way that I can go down, I can say... Well, I've got the hue filter on. So I'm gonna change it. So in this case, this is a fairly narrow band of hue around yellow. Maybe I want to include some more green colors so I can increase the upper limit of the hue saturation. And when I do that and I hit okay, the live video will show the effect of that change. So I can play around with it, and I can see how modifying the particular values has an effect on the robot. So that was the visual side. Let me now move on to the second problem, which is: Well, now you know where the tennis ball is. How do you move to it? And it to kind of demonstrate that this is not a trivial problem, I'll show you a couple of naive controllers.

So the first example is: Given I can see the tennis ball, if it's to my left, turn the motors on full whack. Turn them to the left. If it's to the right, turn them to the right. Sounds simple enough, right? What could go wrong? Well... Ah. That isn't exactly what I wanted. As is always the case... Turning the motors on full whack probably isn't gonna solve it. That was silly. Let's try something a little bit more clever. Instead of full whack, why don't I scale the amount of power I give to each motor based on how far it is from the center? If it's way left, it's motor full whack. If it's a little bit to the left, I put a fraction of the power on. Let's see how this one does. So it gets close. But it's got this oscillatory motion. That's weird. So the naive approaches aren't working. You can continue to try this a bit more, but actually what you want to do is... You need to have an understanding about what's actually going on. So there's a couple of things that you can do.

The first one is: Instead of trying to do this continuously on the robot, you can say... For the sake of... I want to prototype a controller. I'm gonna build the entire thing in software. So this is the same controller block as before. But what I've done is, instead of have hardware blocks that are feeding into this controller and taking its output, I now have a software emulation of the robot. And what you want to do is... Well, this is something that you can now run in software. This is something that you can adapt without having to compile each time round. And it drives you towards... To get a proper emulation of the robot, you need to have an understanding of all the bits of hardware. So you can sort of delve down into... How does the camera behave? How do the motors behave? And figure out those individual pieces, before going back to what controller you write to work this problem.

So I'm gonna just give you a hint as to why it gave that oscillatory motion. This is called delayed response. This is a video feed of what the Raspberry Pi sees. On the right is gonna be a graph of the input. Watch the line in red compared to the video feed. So did you see how early the red line... How late the video feed came after the red line? Let me show you again. So it's doing nothing, it's doing nothing, and now. That's when the motor will be going and that's the response. So it's about a third of a second between when I put some motor input into the robot and I actually see some response. So I need to calibrate the controller to figure out... Okay, it needs to predict where the robot's gonna be and slow down in advance of where it wants to go.

So you kind of build it into your simulation. In this case, I've just shown you a bit more detail. Ignore the majority of it. When you build the simulation of a robot, you take the motor inputs, you use the motor inputs to figure out sort of a dead reckon position of where the robot is and what the orientation is, and from there, you can build: What does it see? But for this delayed response problem, all you need to add to simulate that, to emulate that, is these three plots on the right, which are delay plots. Whatever the signal is at a particular time, output the thing five frames ago. From it. So we can have this as an emulation and try to solve the problem purely in software. And you can try different things out. You can try... I don't know. Imagine that you try to predict where the position is gonna be by adding some multiple derivative. That works to a certain extent. If you do a bit of searching around, what some people do is use a thing called a PID controller. It stands for proportion, integral, and derivative. So the farther you are away from your goal, the more force you need to apply. But if you're not moving, you might need a little bit more force. You're going to be increasing the force over time 'til it starts to move. And finally you want to put the brakes on. To say the faster it goes, the more force you want to apply in the opposite direction. This is what a PID controller does, and you can take one of these blocks and tune the three parameters to how big an effect these three forces have on the problem, and you can get to something which at least in theory gives you the perfect centering of your robot.

You can see here that its initial guess as to how much force you need to apply wasn't quite enough, so it kept increasing and increasing and increasing until it saw a response, and then it appropriately decreased the power, until it centered on the tennis ball. So again, like the visual analysis, this is something you want to try with a real robot. These are parameters that you want to tune. And again, like the visual analysis, I can take this model. I can take this controller. I can run it on a Raspberry Pi. Connect it to my Simulink, and if it's behaving weird, I can go down and I can figure out... Or I might need to increase, say, the derivative, to give it more braking power. Or I need to decrease the proportional field, because it's overshooting. So I can do things like this, while the robot is actually running. And trying to find the tennis ball. So putting it all together, once you solve these two problems, visual and controller, you can put everything together with the camera and the motor outputs. And this is now something, like I said before... You can compile, you can run on the Raspberry Pi, and you can generate code from it that you can then leave on the Raspberry Pi, and it's now a fully functional robot. Loving all the tennis balls it can find. So... That is pretty much what I had to show you. This is how MATLAB, an analytical scripting language, and Simulink, which is an application around modeling systems over time, how these two applications can help you with a basic hobby project like making a robot that loves tennis balls a bit too much. So thank you for listening.

(applause) 



>> Great. Thanks very much. We have a few minutes for questions, so if anybody has questions... Hang on.

>> (inaudible)

>> I'm afraid not.

>> It produces C code?

>> It produces C and C++.

>> You mentioned that MATLAB and Simulink are now available for hobbyists. Where can I get it, and how much is it?

>> So I can't give you exact pricing, because I'm not a salesperson. So you can go to our website. And if you look at... So there should be links from there to home use licensing. And you're talking of the order of, say, 100 pounds for MATLAB, 100 pounds for Simulink, and a certain amount for each add-on tool box that you're looking to do as well. So it's of that order.

>> Okay. Not the 3 grand that it costs commercially.

>> No.

>> Other questions? Cool. Okay. Well, just two reminders. The same reminders. Which are about the bar.


