
>> I have a few announcements. We're looking for volunteers. It shifted slightly. We're looking for volunteers for the bar session tonight. That's the bar, serving beer. Not being on the other side of the bar. I have to emphasize that bit. Also, music has to stop at 7:00 pm tonight. That's amplified music. So switch everything off. Thank you. Even the people next to me at 4:00 am playing music. That applies to them. I'm very pleased to say we have Mitch Altman with us. Music is a wonderful thing, unless you've tried the synth on the badges, in which case your neighbors may not agree. But I'm happy to say this is going to sound a lot better with what he's doing today, which is the ArduTouch music synthesizer. Mitch!

MITCH: Thank you. Great. So thanks, everyone, for coming. The contact information on the screen is real. Please feel free to contact me any time for any reason. I am totally happy to answer questions about this project, but also about really anything you might feel I can help with. Excuse me. So I've been giving workshops. My voice is not so good. But bear with me. I go around the world giving workshops and talks, and I love doing workshops. And talks. I give little ones and big ones. I teach soldering. And I like teaching soldering. When people come together and solder, everyone just seems to be happy. I mean, like... They look happier, right? This is what it looked like over in the hardware hacking area the last three days. And we've got a few more hours, if anyone wants to come by, until they kick us out. Feel free! I wrote a comic book about it. Like everything I do, it's Open Source. You can download this. And it's in lots of different languages.

All the kits I make are Open Source. My first kit was TV Begone kit. That's how I make a living, with TV Begone key chains. I sold 600,000 of these. And me and 12 friends have made a living at it for the last 12 years. It's amazing. And doing the kits, I don't make any money from that, but as long as people want them, I'll making them available. These are just some of the kits that I have. My latest kit is the ArduTouch music synthesizer kit, which has been extremely popular. I had the first early version about two years ago, but the hardware is super simple. This board has an Arduino in the corner, with a chip and just a handful of parts. It's an Arduino Uno. And there's a little audio amp in the corner with a speaker, and the bottom half is just a keyboard, a touch keyboard, and a couple of knobs and a couple of buttons. So the hardware is quite simple. And I call it ArduTouch, because it's an Arduino with a touch keyboard. Not a great name, but whatever. You get the idea.

And the last two and a half years I've been working on the firmware. The controlling program. And that's the hard part. And I'll talk about some of that. Just some pictures of workshops I've been doing over the last couple years, with the earlier version. It's totally mature now, though. But it's still a work in progress. I'm still making it a lot better, along with the help of my friend Bill Alessi, who's a brilliant firmware engineer. So my motivation for doing ArduTouch was to make something that makes sound. You can learn to solder with it. You put it together. And it just works. And it makes a cool synthesizer. Because I didn't really see many kits that make really cool sound and music and noise. And I like sound and music and noise!

Noise is great. So when you make this, it just works. And it's easy to debug if it doesn't, because it's a simple kit, as far as the hardware goes. And if you want to, you can learn a little bit about Arduino, or if you already know about Arduino, then you can reprogram it to use any of my synthesizers, and reprogram it to some way cool variety of different music sound and noise. And if you want to learn even more, then you can read the documentation and follow some examples and learn to make your own synthesizers. And if you want to learn even more, then you can read my documentation, which I'm improving all the time, to learn digital signal processing, which is a fancy phrase for how to manipulate things with a computer to do cool things in the world.

So here's just one demo video.

(swooping electronic bloops)

This is the one it comes with. It's called Thick. It's four sawtooth waves. And you can manipulate it and make a variety of different sounds with portamento, gliding between notes, and a couple sounds otherwise. It's kind of cool. This is what you hear when you build the ArduTouch, and it just works! It's fun. But just to put this in some context, not that my project matches up to these other people's, but... I've been fascinated with electronic music all my life. And people have been playing with electronic music for a long, long time. One of the earlier people who is one of my musical heroes, is Theremin. He made the thing which is best known for really bad Hollywood Sci-Fi movies. Or the original first season of Star Trek, with a human-like voice going OoooOOOoooooOOOOoooh! That's a theremin. And when I went to university, it turned out that one of my advisors had been playing with music synthesis since he was a kid. And the black and white photo is his PhD thesis. It's a whole bunch of oscillators that mix together to make lots of super interesting noises.

And I was just at the University of Illinois as hacker in residence earlier this year, and met up with him, and there he is, looking a bit older than when I remember him as an advisor, but he's still doing great. And here he's playing an emulator of his original synthesizer that was from 1964. As a little kid, I was fascinated with Switched-On Bach, by then-Walter, now Wendy Carlos. Wouldn't it be cool to have a wall of things like that, that you could plug things into, and whatever? So Switched-On Bach was one of my favorite records as a kid. When it started becoming part of rock and roll music, I had another musical hero with Keith Emerson. He could even play this synthesizer upside down on a stage. Kind of acrobatics. But it was fun.

And later in the '70s was the first one you could actually buy for affordable -- this was like $80 in the US. It made cheesy sounds, but you could buy it, and it worked. And later there was one that I got used, that made all sorts of crazy noises. The DX7. Oh, that caption is wrong. That's a DX7 by Yamaha. I had been making synthesizers since I was in middle school, simple ones, and in high school it got more and more complex, and it turned into my masters thesis to have a digital synthesizer. That cost a lot of money, but our lab had a million dollars worth of microcontrollers that were donated by Intel, which helped me in my music quite a bit. Now it's much easier to do things. And the ArduTouch music synthesizer is just $30 US. And it's really easy to play with. You don't have to study manuals for months and months like a DX7.

Music synthesis has two major kinds of approaches. There is analog and there's digital. And analog is -- like in the real world, everything is analog. Everything is smooth. Everything is connected to everything else. There aren't major jumps, unless you're talking about quantum and really, really small or really, really big things. Much bigger than our day-to-day lives or much smaller. But in the real world, it's all analog. And doing digital means you've got to muck with the analog world, get it into a digital form, and then muck with it some more to make interesting things happen, and then turn it back into analog.

And there is a lot available nowadays. These people, Teenage Engineering, make lots of interesting little modules that do fantastic things, and they're super inexpensive. And there's also, of course, fantastic performing musical instruments that are still analog and digital. Analog I still think is the greatest. But you can do so much with digital. On your own. That's hard to do with analog on your own. So... With analog, quite often it's just some simple wave forms. The smooth up and down called a sine wave, just on/off, on/off, a square wave, a triangle wave, or a sawtooth wave, shaped like the tooth of a saw, which is why it's called that. They're interesting sounds. And if you mix them together in different combinations and different pitches and muck with it in certain ways with filters, you can get amazing sounds.

And great noise! With digital, you can try to just emulate an analog synthesizer, like the old Mini-Moog. I actually had a roommate in university who had a Mini-Moog, and we made lots of sounds and annoyed the hell out of our neighbors, which is always a fun thing to do. But with digital, you can emulate an analog synthesizer. It'll never be quite as good, but you can get quite, quite good. But with digital, you've got to take whatever is in the real world, break it up into little bits, because that's what computers use, is bits, bytes, words. And then mess with it in certain ways. Either through calculations or realtime with knobs and buttons, and you can use all sorts of interesting math to muck with it as well. And then put it back together again to put it out into our world, where you can hear music, sound, and noise.

And to do that, digital signal processing really, really helps. That fancy phrase. But it's really not that difficult, to be able to play with this stuff. And I'll talk about that. There's various forms of digital synthesis. And my ArduTouch digital synthesizer makes use of all of these. The easiest one to talk about is coming later. But additive is a really interesting way to make sounds, and my advisor from the University of Illinois back in '64 did additive synthesis to create all the sounds he makes with his gear. It's just a bunch of sine waves. Some dead French mathematician named Fourier figured this out. If you have sine waves of different amplitudes and frequencies, you can add them together to make any wave form you want. And here's just a few pictures to show how to add a few sine waves together to get a square wave. If you do 13 of them, it's pretty much indistinguishable from a square wave. Here we have just four of them showing how to get really close to a square wave.

You can also have FM. FM is a sine wave, a frequency -- a sine wave where the frequency is changing over time. And it's a sine of a sine function. And this is what the DX7 used very effectively in the first very popular FM synthesizer. And this makes just totally nutty sounds. But it can make really beautiful sounds as well. Like a bell or a trumpet that was very difficult to do earlier with analog synthesizers. But to get into this form, wavetable, you can think about a tape loop. So tape loop... It's kind of like with a vinyl record. Old vinyl records. If you turn the motor off, and you can spin it with your finger, you can make it go slow or fast. And people who scratch make use of this. They also go backwards. The sound is recorded in the grooves of the record. In a tape loop, though, the sound is recorded in a continuous loop of sound, and you can make it go faster, you can make it go slower with a motor controller. And you can... If you have a record head, you can put new sounds into it, and it just repeats and repeats. And a wavetable is kind of like that, except the sound is put into a form that a computer can understand.

Digitized. And then we can play it back from memory, faster or slower, but we can also do lots and lots of things that are more difficult to do with a tape loop, like do mathematical formulas on it, and all sorts of interesting filtering techniques, and muck with it in lots of ways. For digital, we start off usually with the analog world, and then convert that into a form computers understand. So we can take just a simple sine wave. Here's one cycle of a sine wave. And to make it into a form that a computer can understand, we've got to slice it up into chunks. This is called sampling. That's the fancy digital signal processing word. Sampling. So here I cut up a sine wave into ten slices. And each slice has a value. We can put a dot where it crosses the waveform, and each of those dots has a value. You can put the values on like this. And then record those values in a table.

It can be a piece of paper. That's not so useful. But if it's memory, now we have it in a computer. Where we can he use it and muck with it and do all sorts of interesting things with that. So this is sampled sine waves with ten samples. Usually we use much more. I'll show you why soon. This sample is stored in memory. It can be a simple waveform, but it can also be a complex waveform that's several seconds or even longer. This is sort of a simplified version of a piano-like sound, part of a piano-like sound, and those values are stored in memory. In order to get from a waveform in our real world, the analog world, into memory, that process is called analog to digital conversion. And here's a little diagram of that. We can take the waveform, put it through an analog to digital converter -- that's just a black box -- and then out comes values that are stored in memory. People in the field call this A/D. A to D conversion.

But how do you do that? What is that black box? Well, that black box can be a chip. And to see how all that works can take more than I can go over in this talk. It's not all that bad. But if you buy the chip, you can just set it up according to the schematic in the data sheet, and it just works! But nowadays even inexpensive microcontrollers have them built in. So they're basically free. And once you have it, you probably want to play it back. You might want to play it back exactly as it is. Or you might want to muck with it first and then play it back. But in order to do that, you do the opposite. And that's digital to analog conversion. So it's just the same thing, but reversed. We have a different black box now, called digital to analog converter.

And out comes the waveform. Ideally. And then from there you can put it into an amplifier and rock and roll. So that's the idea. So D/A is the fancy professional way of saying it. But that's really what it is. And so what's in this black box? Well, again, you can have a chip, which is really expensive, actually, to get a good one. Or you can use PWM. And I'll say what PWM actually means after I go through a few more slides, so you can understand that. PWM works with basically square waves. So a square wave, though, is on/off, on/off, on/off. And it's half on, half the time it's on, half off. Same time on, off. On, off, on, off. And so with a square wave, it's basically half the amount of energy of if it's on all the time. Because it's off half the time as well.

Rather than have just square, where it's 50% on, 50% off, we can have different ratios of on/off time. Like a pulse wave. And analog synthesizers make use of pulse waves just to make interesting sounds as well. But here's one that's 25% on and 75% off. And that ratio is called a duty cycle. So it's 25% -- that means there's 25% of the energy coming out, compared to just on all the time. And we can have various ratios. It doesn't have to be even numbers, either. It can be fixed point down to as many decimal places as you want. It can be on for 37.4644... Whatever. It can be any value. And you can vary the amount of energy coming out by varying the width of these pulses. And when you vary the width, when you change something over time, in electronics, that's called modulating it. And what we're modulating here, changing over time, is the width of the pulse wave. Oops. Pulse width modulation. PWM.

And this is the way that you can make all sorts of amazingly beautiful and nasty noises out of a microcontroller. And it's free! Because all microcontrollers have output pins. And many of them have timers, which are designed for PWM. Make it easy for you. So the same diagram before, except the black box is labeled PWM. So we have values in memory. We feed the first value into our D to A converter. Digital to analog converter. Out comes the first little bit of our waveform. Then feed it the next memory location. Out comes the next part. And you go through the whole table byte by byte or word by word, and out comes the waveform. You can put in an amplifier, and rock and roll! And it's totally cool. You can make really cool, nasty, and wonderful and beautiful sound, music, and noise.

So that's the theory. In practice, however, there's a bunch of gotchas. So this is what we want. We want a table full of values. That's our waveform in digital computer form. Feed it through our black box. Digital to analog converter. And out comes a perfect waveform. In this case, a sine wave. In actuality, however, we get this. Because computers don't have all the values in between. We only have samples. Each memory location is just one point of the waveform, and that value stays there 'til you put the next point in, and the next point, and the next point. And this sounds nasty. That might be a good thing, but if you don't want that, you want to be a nice smooth, wonderful sine wave, you're out of luck. So in order to fix that, according to theory, all we need is a perfect low-pass filter. A low-pass filter lets low pitches through, but not high. A perfect one -- you pick a frequency. Everything below comes out perfect. Everything above doesn't come out at all. And if you have a perfect one of those, then you get a perfect sine wave out. But of course, perfect doesn't exist in our real world.

But we can use a really cheap one. So perfect doesn't exist, but we can use a really cheap low pass filter, which on my ArduTouch is just one capacitor and one resistor for each channel. And I've got two channels. It's stereo. And from this, if you put it through my cheap low pass filter, you don't get a perfect sine wave out. You get this kind of... Messy-ish sine wave out. And that actually sounds okay-ish. To fix that, what we do is we have more than 10 samples for a waveform. We have, like, 256. And if you have 256 with this cheap one, you get pretty much a perfect sine wave out. Not quite. Our ear is more sensitive than our eyes. It looks like a perfect sine wave, but it sounds a little bit scratchy. But I pulled some other tricks, and some waveforms that I wanted to be really smooth, I have way more values than 256. It also helps if the values are more than 8 bits. If the values are 16-bit words or even 32-bit words rather than 8 bit bytes, then the values are much more accurate.

So that's really all there is to it, to get from that analog world to computerese. And then from computerese back to the analog world, where we can make music. But that's just showing how to get the waveform. What we really want to do is change the pitch a lot. Because we're playing a keyboard or playing with a breath controller or all sorts of things, or just with knobs. We want to get all sorts of frequencies. Lots of different pitches to make crazy sounds and music and all sorts of things. So how do you get different pitches? Well... In order to explain this, I'm afraid I've got to do a little bit of maths. I hope that's okay.

Sorry about that. But it's cool maths. So if we have 256 memory locations to describe a waveform, and we send one value out at a time to the digital to analog converter, and out comes our waveform, what is the frequency of it? Well, if we send one every second, then we can have the complete waveform in 256 seconds. That is way too slow for human hearing. For human hearing, we've got to have a 20th of a second minimum to do a waveform. And that's a really, really low note, and we want all the way up to a 20,000th of a second. So one hertz -- that's a way of saying one per second -- isn't fast enough. And this again is called the sample rate. The rate at which we play the memory locations through our D to A converter, to get the sound out.

So let's -- instead of one second, in the ArduTouch, I use 15,000... Oops. Already went over that. We use 15,000 samples per second. 15 kilohertz sample rate. And when we do that, we can get much more interesting things. But still it's rather limited. If we just do the 256 samples in our memory and play them one at a time, 15,000th of a second later, we get... 15,000/256 memory location samples, and we get 58.6 hertz. 58.6 cycles per second. That is basically the frequency we get out, and that is a pitch near A sharp. The lowest A sharp on the keyboard. That's not a very useful pitch. Especially if it's the only pitch we can make. No one else can play with us, unless they go off-tune on a violin or a slide flute. So... What we want to do is get any pitch we want. If you have a keyboard, you want to get every note on the keyboard. If you have a knob, you want to get every sound you can hear from the range of human hearing. 20 times a second to 20,000 times a second. We can do that in two ways. One way is really hard. And that's like a tape loop. Change the speed of the tape going around, or change the rate of all of the memory locations, feeding them in the D to A converter faster or slower.

We can only get 58.6 hertz max. So that's not really a good way to do it. And slowing it down is complicated in code. So the one way to do it is to skip memory locations. And if we skip them, then we can get a faster sounding... We get a higher-sounding pitch. And skipping them is in quotes, because what we're really gonna call that is interpolating. And let me show you how that works. So let's say we want an A. And in music, A -- 440 is defined as 440.00000... Times a second, hertz. That's the definition of middle A on a keyboard. In all instruments. So if we want to get 440 hertz, and we got samples coming out every 15,000th of a second, we divide 440 into that. And we get 34.09 steps. So that means that we skip 34.09 memory locations every time we do an output of a sample.

How do you get a 0.09 memory location? Well, you can't. You have location zero, one, two, three -- only integers. You can't go to location 1.5. That doesn't exist! Or 34.09. That doesn't exist. But we can interpolate between location 34 and location 35. So we'll skip 34.09 every sample. And I have some pictures to show how that works. So we start off with just the first one. Location zero. And whatever value is in there goes into our D to A converter, and that's the first slice of our waveform. Then we go to location 34.09. We can't do that, but we can go to some weighted value between location 34 and 35. It'll be really close to the value in 34. And then we add 34.09 to that to get 68.19 and we have another weighted value between 68 and 69. We get to the next one, 102.27, et cetera, et cetera. And in the 7th value, we get 238.68. It's still in our table. But the next one will go below the memory locations that we have.

So we wrap around to the top. So this would have been 272.72, but we wrap around by subtracting 256 from it, and now we're back in our table, and now we have location 16.72, a weighted value between 16 and 17. And we just keep going around and around and around, and we do that at that rate, and out comes a perfect waveform through our cheap low pass filter at 440 hertz. A. Middle A on the keyboard. And it can be the sound of a normal piano, it can be the sound of a sine wave, a square wave, a violin-like sound, a trumpet sound -- whatever. It just depends what's stored in the memory. And that's really all there is to it.

To do it... Conceptually, maybe you didn't follow all that absolutely perfect. But hopefully you have a feel for what I went through. And to code that is kind of complicated. But I already did it! And if you want to hack on my code, feel free. It's totally Open Source. But I made it really easy by putting all that low-level stuff in a file, and having all of these functions in an Arduino library. So that no one really has to do that, unless they want to hack on my code. And feel free. And if you come up with something cool, let me know. Because I'll share it with other people, then. But my ArduTouch makes it really easy to do all these things. And that's part of the idea. To make it easy on the highest level, but make it so that it's totally hackable, so people can do all sorts of more interesting things than I've come up with.

So the ArduTouch library makes it really easy to create oscillators. And those are the various waveforms that can be the simple ones like sine wave, square wave, triangle, et cetera. We have a whole bunch of really interesting, very complex, beautiful, and nasty, noisy waveforms as well. But if it's just an oscillator, even if it's a beautiful or nasty or whatever kind of waveform, it's kind of boring. Because it's not changing over time. Any actual instrument -- analog instrument -- mechanical instrument -- it changes over time. A great deal. And it sounds much more interesting than just... On with a static sound. And then off. So for doing that, we have dynamics. And I'll have some explanation of dynamics in a bit. But that is what makes the sound super interesting. The oscillators, like I said, can be the simple waveforms or more complicated ones. The dynamics can be some of these and other things. ADSR is what happens when you play a note.

Like, on a piano keyboard, when you press the key, it goes Unnng! And that's the attack. Unnnng! And it decays quickly. Unnnnnnnn... g. And as long as you're pushing the button, it sustains, and slowly goes down. Nnnnnn... And when you let go of the button, it goes down to zero rather rapidly. And that's one waveform for attack-decay-sustain-release. And this is called an envelope for the waveform. You can do much more interesting things with envelopes than that. Especially if you want to get nasty noises. But you can muck with the attack-decay-sustain-release. And ArduTouch makes that easy. Tremolo is really another envelope generator, except it's usually constant. Tremolo is changing the volume over time. And you can change it sinusoidally, so it's like... EhhhhHHHhhhhhEehhhHHhhHHHhhHHH... So the volume gets higher and lower. You can also do it in a square wave, so it's just... On/off, on/off. Eh. Eh. Eh. And you can do other waveforms too. And if you do it really, really fast, faster than the pitch, then you can get super crazy sounds, and that's really what FM is all about.

And it's pretty interesting. Portamento is somewhat similar to tremolo, except it's changing the frequency over time. OooooOOOoooooOOOOoooo... And it can go much faster or slower. And if you do it super fast, you get interesting things too. Sorry, tremolo isn't FM. The portamento is. And you can do lots of interesting things beyond just ADSR and tremolo. You can do all sorts of interesting waveforms to change the envelope. And filters like bass and treble control, people know what those are. Those are high pass and low pass filters. But you can also have band-pass filters that only let frequencies through in the middle, and you can mess with those over time. Fast or slow. And you can also have a filter in digital that you can't do in analog, which is just taking values and randomly changing them.

And then you get really cool, totally horrible wonderful noises. And you can tell I like noise! I like noise! And then effects. You can add all of these together and you can have all sorts of interesting effects. Ones that correlate with the analog world, like guitar effects pedals, or ones that you just make up on your own. With ArduTouch, I have a bunch of stuff like that. And I make it easy to add these dynamics just by calling a function. I wanted to go over how the keyboard works. The keyboard is just pads on the board. These are just pieces of copper from the board. And I coated them with a very thin layer of gold. So they wouldn't oxidize. But you just touch it, and it plays the note. You can also use the keyboard if you program it as a controller, rather than playing sounds, you can use it for changing the dynamics of the sound. But the way this works is through capacitance. And capacitors are very teeny batteries that charge up really quick and discharge really quick.

Everything has capacitance. The pads on the board, these pieces of metal on the board, have capacitance. Very little, but it has some. So we can charge these capacitors up, these little teeny batteries. They'll charge up really fast, and then we can discharge them fast. If we touch the key, we have capacitance. That adds capacitance to the key you're touching. And so that's a bigger, slightly bigger battery, and it charges up a little slower. And we can measure the difference between the charge times. And here's a graph of that. The green one is charging up with just the piece of metal on the board. The red one is charging up with you touching a key. And there's a difference. And we can detect that with a microcontroller. So we know which keys we're pressing. Right now I just have only one key at a time. But I could change that, and I want to change it, so you can play polyphonic. The synthesizer itself underneath all of this is polyphonic. We can have lots and lots of voices at once. Before the microcontroller, which is actually quite low powered microcontroller... It makes really amazing sounds for such a low powered microcontroller.

And then the other part of the board is the amplifier and speaker. And this also has the cheap low pass filter, which is one capacitor and one resistor per channel. But the chip in here is a really old but still working chip. Called the LM3D6. It's a half watt amplifier chip, and I use the least number of parts possible for it, and I also have a headphone jack so we can have a line out. And I have "line" in quotes, because it's actually too high an amplitude, too much volume for line. To do it for real, I would have to add another chip in there, an opamp, and I wanted this to be as inexpensive as possible. But it does work. You can plug it into a nice amplifier and get super nice sound. And the example I played earlier is from the line out. So yeah. The Arduino library that I made for ArduTouch has lots of examples.

If you go through examples zero through nine, then you can learn how to make your own synthesizers with my library. And, for example, you can make really easily a sawtooth keyboard. So this one... This is the complete synthesizer. Including the comments. That's the complete code. It looks quite simple. And following the examples, you can do this. And you can have sawtooth output just by playing the keyboard. You can change octaves with the buttons. Make it higher or lower octave, and you can change the volume. You can, from there, if you want to, add dynamics. All the things I talked about before. Tremolo, portamento, et cetera. Here's another demo. I do want to say: You don't need my board to use my code. This will work on any Arduino at all.

Mine looks like an Arduino Uno, but if you have a more powerful one, then you have more input/output pins. It'll work on anything. A regular Arduino doesn't come with a touch keyboard and a little amplifier, but you can easily do that yourself. But here's a couple more demos. Here's one that's totally different from the one it comes with. But all you need to do to get this one in is using the Arduino environment, MacOS, Windows, or Linux, and download one of mine, or create one of your own synthesizers and program it in -- takes a few seconds. Here's a demo. I call this mantra. It plays a drone with... A drone... Percussion. And an Indian-like scale. So that you can't play any wrong notes, because every note fits with every other note. And all those voices are just played in realtime. Calculated from wave tables.

And it's kind of cool! Here's one that's totally different. This one's called Zoid. For you noise lovers in the audience.

(grinding noise)

And it can make lots of different noises. The knobs change the noises.

(pitches going up and down)

I'll play it for a bit. Pressing the keys makes different noises. There's also presets to make very different sounds. Noises. And you can just jam with this. It's pretty crazy.

(grinding noises changing in pitch and timbre)

So that gives you an idea of some of that. You can't do this with digital. Right? So this is purely... With analog you can't do this. With digital, you can do all sorts of crazy things like this. But this sounds almost bell-like.

(grinding clanging noise)

And it's an accident. I'm just doing weird things to the bits to change the sound kind of randomly.

(squeaky grinding)

(fuzz guitar)

That gives you some idea. The ArduTouch has a lot of limitations, because it's only a $30 little board with a low powered microcontroller. There aren't many input/output pins. I only have two LEDs, and I can only have two knobs and two buttons. If I had more input/output pins, I could add lots of things. I could add MIDI, a display, lots of things. I want to do that. I have one file in the library which is for the Arduino Uno. If I use a much more powerful microcontroller, I can just change that one file and add lots more functionality. And I'm working on that now. There's also not much memory. The microcontroller only goes at 16 megahertz. It only has 32K of program memory, so the synthesizers can't be too big, and it only has 2K of RAM. So these are all limitations.

But if I use something like an STM32 or any kind of ARM core, you can have built-in USB. It won't be a kit anymore, because the parts are too small for beginners to do, but it can do lots of things with more RAM and built-in USB and have some cooler library functions and have MIDI and all these other things. So look out for that! As I have time between travels. All this is available on my GitHub. So if you do anything cool, definitely let me know. Like I said earlier, I'll share it with other people. And it's all free! Go for it! And if you like soldering, or want any kits, I'm gonna be over in the hardware hacking area. Doing more soldering. And I can teach anyone to solder really well for the rest of your life. So come on by if you want to, until they kick us out today. Yeah. So that's it for my little rant. Thanks!

(applause)

>> Okay. We have time for questions. If anybody has any questions.

>> What was the purpose of the LEDs on the board?

MITCH: So the LEDs -- for programming an Arduino, it programs through serial. And so there's an LED for serial in and an LED for serial out. If you're not using the serial for your synthesizer, which some synthesizers I made you can, and you can control it with just a dumb terminal. And do interesting things or your own, like, controller, through serial. But if you're not using that, then the indicators can tell you what mode you're in. Like, there's only very few controls on the ArduTouch. Two knobs, and two buttons. So I can put the knobs in a different mode. So instead of doing attack and decay, I can have it change the timbre of the sound and change the volume, for instance. The red light will turn on if you're like that. The blue light will turn on when you're in another mode. Both of them are blinking when you're in a third mode, and things like that. It's not the best user interface, but I make use of what I have with an inexpensive low powered microcontroller. More questions?

>> How do you plan to tackle polyphony?

MITCH: So with the low power microcontroller, the max I can have at any given time -- four independent voices, before the speed of the microcontroller is a limitation. And then you get glitches. Which sometimes are kind of cool, if you like noise. But not if you don't want them.

>> I'm more interested in the detection of pressing multiple buttons.

MITCH: Oh, right. So I just go through each one and I look at this key. Is it being pressed? Yes, no. Look at the next key. Is it being pressed? Yes, no. That can be put in a small table. And that's going much, much quicker than our human timing. And you won't be able to tell there's any lag at all. So that's really, really slow, compared to all the processing going on for generating all the sounds. So that shouldn't be too hard. But I didn't really design the interface with all my Arduino library functions to be able to handle that, so there's gonna be some... A bunch of rearranging things to make that happen. That's the hard part.

>> How easy is it to import your ArduTouch library into something like MicroPython? I think the badges have got MicroPython on them.

MITCH: Oh, our EMF badges? I haven't had much time to look at the EMF badge, unfortunately. So I don't know what processor it has. If it's Arduino compatible, and there's a board file you can download for the Arduino environment, then it will be trivial. Because... You might have to change...

>> I think 2016 had MicroPython running on it. Instead of the... I assume it was on top of the Arduino thing. But a lot of people might want to keep MicroPython on there. So I was wondering whether you could import a c include file into MicroPython.

MITCH: I don't know MicroPython well enough. I don't know Python too much. To me, C is a high level language. This is written in C++. If there's a way to interface C++ with MicroPython, then you can have MicroPython shells as a layer on top of it, then you can do lots of interesting things. Especially for user interface. You know, the board's microcontroller definitely has a lot more power. So it could be able to do lots of interesting things. And I did notice as our herald pointed out there's a synthesizer on the badge, but it says it's not working. Please check later. So if anyone works on that and gets it working, I would like to play with it. But that one, I presume, is written in Python.

>> Any more questions?

MITCH: Comments? Derision?

>> Yeah. The synthesizer does work on the badge. It does. But it makes an awful noise. I enjoyed it, but it was... It's painful.

MITCH: I want to do one more example here.

(glass harmonica-style noise)



MITCH: This one does arpeggios. And you can change the attack and decay. And you can go up and down octaves.

(arpeggios)

MITCH: Here's another mode. You can see the red light turns on. Now I can change the pattern. And I can change the speed. Make it slow or fast. And then you can just play with it.

(arpeggios getting faster)

MITCH: And if you want to, you can tell it to play itself. It has a random number generator in it, so it will never repeat, and it has Bach-like modulations. Modulation in this case meaning changing key in musical... So that's one of the many synthesizer examples that I have available on my website. Oh yeah. Let me show you where to get the website. So there's my website. If you go to the projects tab, then you get my long, horrible page of lots of projects. They're all open hardware. And there's this one, and there's lots of stuff including really good assembly instructions. Lots of demo videos. And each synthesizer you can download, and the instructions on how to use it are there. Including this one and others I showed, plus some others. Any questions?

>> How easy would it be to hook up clock input into it, to sync up with other instruments, perhaps? Or is that a modification that would be there in the future?

MITCH: That would need another input/output pin, and I'm using all of them at the moment. But if you take away some of the functionality, that frees up an input/output pin. One thing a friend did in Croatia is he took away the touch keyboard, which needs one input pin per key, and did a bunch of buttons. With a bunch of buttons, you can do that with way fewer input/output minutes, and that freed up a few pins to do other things. And you can have that sync up to another ArduTouch or another synthesizer.

>> Just following on from that last question, I was thinking... If you do have the serial header exposed, so you've got the serial input, could you not take a MIDI clock in through that, without having to free up any other pins?

MITCH: Oh, that's an interesting... MIDI really is just RS232. But... This isn't RS232. It's TTL-level. So with just a little bit of circuitry on the outside, converting plus or minus 12 volts into 0 to 5 volts, we should be able to add some of that functionality in. It's an interesting idea. And also it's a weird baud rate, but this is programmable baud rate, so it's not a problem.

>> Okay. Cool. If we don't have any more questions, just quick reminders: Music, amplifiers, off by 11:00 tonight. And volunteers for the bar will be greatly appreciated tonight especially. And feedback on EMFcamp.org/feedback. Thanks very much to Mitch!

(applause)


