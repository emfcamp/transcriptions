>> Our next speaker is Muhammad Sayed, who is going to talk about how to make a humanoid with a 3D printer, a wheelchair, and ROS. Over to Muhammad.

MUHAMMAD: Thank you all for coming. So today I'm gonna talk about my experience building this, and what I learned from building it. I didn't design this robot. The design files are on the internet. But mostly what I'm going to be talking about today is what I learned building it. The talk will be split into mainly two parts. The first part, I'm going to talk about the software that I'm planning on using or currently am trying to use. It's called Robot Operating System or ROS for short. And I'm gonna just quickly introduce what does it do and why I'm using it. ROS is essentially a collection of software pieces. Libraries and APIs. That are intended to facilitate how you use hardware to make robotic systems. To build robots. And it is designed or maintained and developed by a large community, mostly academics, but also people who are hobbyists and people from companies. Essentially, if you think of a robot as a set of sensors and activators, you have drivers pulling information from the sensors, like cameras or a Kinect sensor, and drivers operating the actuators, like the motors on the robot, and you have AI or whatever software you're writing to, to get the robot to do something useful. Unfortunately, this robot right now is not gonna do anything useful. Part of it -- we couldn't carry everything here. And the other part, it is still a work in progress. Pretty much a lifetime work in progress. ROS runs on pretty much every robot. It's designed to be as generic as possible, to work on any kind of robot, from humanoids to arm robots to cars to drones.

It does that by abstracting everything and making all the parts of the robot very modular. So if you want to, say, move the robot around, you command the robot in three dimensions, to move forward or sideways, and you have to write the software to understand your command and actually move your own robot. So you normally have on your computer ROS itself running, and so many different smaller packages or code nodes will be operating the different parts of your robot. So you have a node that is operating the camera, picking up the information from it, picking up the image, and you have another node that is processing the image to output whatever features you're looking for. And you would have another node that is maybe commanding your arm to reach out for something that you found in the image. And all these nodes talk together using messages. What is called in ROS essentially just the data stream. Each node is sending out the data after it's processed and whoever is listening for that data -- either node can listen to that data and take action based on it.

This can also happen on different computers. I'm gonna refer to a workshop I'm planning to run tomorrow. You can run the system on a robot, and then you can control it from your laptop. To do more advanced things that maybe the computer on your laptop cannot do. So, for example, in that workshop tomorrow, anyone who is gonna be using the robots -- the robots themselves have a very small computer in them. They have a Raspberry Pi. And you run it on top of your computer. It's called Robot Operating System, but it's not really an operating system in itself. You run it on top of another operating system, which most ideally is open too, and as I said, you can run it on any different kind of robots. And these are the robots that are designed by the people who made ROS. But you can -- as I was speaking now -- you can run it on even any robot that you have designed yourself. So this brings me to Kermit, as we call it.

It is designed based on InMoov robot, which is a 3D printable full sized humanoid robot designed by Gael Langevin. I'm not sure I pronounced his name correctly. You can download the files for this robot from his website, and you can follow the structures there to print the full sized humanoid robot. Just a disclaimer here -- a lot of the photos here, I actually just pulled it up from his website, straight away. So the original design does not use ROS. It uses something called MyRobotLab. Which is not... It is designed by a group of, I believe... They're not academics. They are hobbyists. Or amateurs.

By amateurs, I mean they're doing it because they like to design the software. Which is a very good thing. But I prefer to use ROS, because that's the software that I'm more familiar with. And as my background as an academic, I have used it more often. So I had to modify the original design to make it work with ROS. And this is what I will mostly be talking about today. So as it stands right now, it's the top half of the humanoid robot. In our case, it is sitting on a mobile base. We couldn't bring the mobile base to the camp, unfortunately. It was quite heavy to bring. But as you can see, the mobile base is simply the lower half of an electric wheelchair. And yeah. I will speak about printing it the same way -- making it the same way it was... The files were published. So the very first part of the files that were published, back in 2011, were the parts for the hand.

Now, for my design, I followed the instructions pretty much the same. You will print the different parts for each finger as separate pieces and glue them together. Then after assembling the hand, you need to run some wires or tendons through the fingers, to the forearm, to operate the fingers, to open and close the hand. The first problem I came across, when I did that, is that the tendons would... I would say scratch against the corners of the different parts of the hand. And they would get ripped apart. Sadly, I don't have a photo to explain that, but the solution for that, I found, is that you can run the tendon inside a tube. So there are flexible tubes that you can buy. Very commonly now used for 3D printers. It's known as Bowden tubes, if you're familiar with 3D printers. And you can get thinner tubes than that. The tubes I found to work best is a 1 millimeter diameter tube, which can run to the forearm, and you can run your tendon inside that tube to avoid all the scratches.

Now, in the forearm, in the original design, Gael used five servo motors to operate the hand. I did at some point... Right now, the motors are not there. But at some point, the motors were there. The problem with the original design is that you will have many cables that need to run up the arms and back to the controllers that normally sit on the back of the robot. The simple solution that I found is to put a small Arduino inside the forearm, which will control the hand independent from the rest of the robot. And then you can command that Arduino just for the hand to open and close, or for the different finger movements. Additionally, that allowed me to add more motors to control the different joints of the fingers separately. So the human hand can control different joints, so you can close your distal joints without closing your proximal joints. Or you can close the proximal joints without closing the distal joints. If you're only using one motor per finger like the original design, you wouldn't be able to do that.

But then if you have an Arduino in the forearm, you will need probably to use smaller motors in that case. But you will be able to use more motors, because you wouldn't have to run all these wires up to the Arduino that originally was controlling the whole robot. The other thing is, because I'm using ROS and because it is developed to be a very professional system, it requires feedback. It requires to know the position of the joints at any time. So in the original design, you would only send a pulse width modulation signal to the servo motors for them to move to a certain position. You don't have a feedback to the controller to tell it that the motor has actually moved. And because it's just pulling a tendon, you don't actually have any feedback from the joints that the joints actually moved. You could have... Maybe the tendon stretched a bit, or even broke. So you wouldn't have any feedback from that. So the solution I found... I tried first to modify the joints so I could put potentiometers inside the joints. I couldn't find potentiometers small enough. I don't have photos for that, but the solution I found was to put flexi sensors on the back of the hand. They are simple long strips of plastic, which has a conductive material in the middle of it, and as you bend it, the resistance of these sensors -- the resistance of the material changes. You can easily find them in all the websites that sell Arduino stuff.

And you only need to fix those to the back of the fingers and then you can connect those to the same Arduino that is controlling the motors in the forearm. And you can send that back to the computer to tell it how to... How the hands look like at the minute. So that gives it feedback. You can also put something called FSR, force sensitive resistors. Again, it's also similar to flexi sensors, but it changes resistance by pressure. And I've tried to use it for a while on the fingertips to detect if the fingertips are actually holding something. I'm afraid I'm not putting any code here to show actually how to do this. I will be sharing the code online. If you want. Or you can come and find me in the fizzPOP village behind the stage here. I can explain if you need any advice on how to do the coding. So for the forearm... For the whole arm... The original designs were using, again, servo motors. These were using bigger servo motors. And each servo motor will have the wire running all the way to the back of the robot, where the Arduino controlling the whole robot sits. Now, the modification I made here is because I did not want to have all these wires running back, because that adds problems. As the robot moves its parts, it might damage the wires or disconnect the wires.

I used a digital servo. I'm not sure it's very visible on the screen. It is from a kit called RoboBuilder. I made a holder for that servo motor, to fit... To fix in the same place, where the 1/4-scale servos that were originally used sits. And the benefit of these motors is that they are addressable and they can be cascaded. If you see in the photo, for each motor, there is one wire going in, over one set of wires. Four wires. A cable with four wires. Going in, and then there is also a cable of four wires coming out of the motor. And it is actually... At the top, you will see that the cable going up and going back down is just out of the photo. But it's actually going from one motor to the other. And all the motors that are addressable and they can be controlled by a serial connection... So just send out to ID the motor... And what motion it should do.

So that gives you control of the speed of the movement, and the accurate positioning of the motor. And the only problem with this approach, compared to the original approach, is that if you look at the original instructions, the sensor was removed from inside the motor, and placed directly at the joint. Because there is a gearbox between the motor and the actual joint, the position of the motor does not tell you what the position of the joint is, but ROS needs to know the position of the joint. The solution for that I have not implemented yet. I've ordered some parts, but I haven't gotten them yet. You can use separate encoders, and I would recommend using magnetic encoders, because then they don't add any force on the joints, but most ideally, they are more forgiving in the positioning.

So you could fix a magnetic encoder on the joint straight, and you can get the feedback for the actual position of the joints. Another thing I modified in the arms is that I added some metal reinforcements. So you'll see a rod going down the forearm. Now, the forearm is originally printed in about 12 parts that are glued together. And it's rather thin. So if you're trying to lift something heavy, it could break. In fact, if you want to come and see the robot later, it actually did break quite a few times, and I had to glue it several times. I added a metal rod running down the front arm that connects it from the bit where it connects at the elbow, all the way to the wrist. So unfortunately this is not a modification to the file. This is a very manual modification. So I cannot really share the files for that modification. But if you want to come and look at it closer, you are more than welcome to do that.

After this modification, the arm was able to lift relatively heavier objects. And it didn't break once. It did not break because of lifting something. But it still ended up breaking because of people walking into it, or it falling over or something. I didn't make any modifications of the head, except that I fixed a bit of speakers inside the head. So the head print -- you can print the head in... I don't remember the count of the parts, but several parts, again, that you glue together. And you can put cameras in the eyes. The original design put two separate cameras in the eyes, which can be activated by servo motors, so that they can move and give a more realistic look. But I put a fixed stereo camera, which originally comes with two cameras spaced at the average distance between the human eyes, which is roughly 6 centimeters. I would not do that again, though, because there were some problems with that stereo coming on one USB cable. The amount of data coming from both cameras would cause connection problems.

So the only solution to that is to actually reduce the resolution coming from the two cameras, which then cannot really provide enough data to do any processing on stereo images. So I would... If I am to rebuild this, I will stick with the two-camera solution. I added two speakers in the mouth, but then there is some derivative designs online as well, that use speakers in the mouth. Now, the mouth is activated, so it can open and close the servo motor, and the whole head is activated. It can turn sideways and go up and down. In the newer designs, I had already printed this a long time ago. But the current designs also have the head being able to tilt sideways. So if you print a newer design, you will have extra two motors that are at the sides of the head, that is tilting the head sideways.

The chest of the robot. Because it's originally designed to be 3D printed, the chest is made into so many different small pieces that you can 3D print and join together. The joints are not very robust. I found that out when the robot fell and the same joints which are used in the shoulder all broke. So... I ended up having to reinforce all the joints in the shoulder. But for the chest, from the start I did not 3D print them, because there are so many, and they would take a long time to print. I would recommend just laser cutting them. I did find a few files online. I didn't share my files when I modified it. There was no files online. But by the time I have modified the files, there were some other people who did the same and shared their files. And I realized that my files had so many mistakes that I had to fix by hand later. So I didn't want to share them. However, if anyone wants those files with the mistakes in them... Let me know, and I can give them to you. So as I said, laser cut all the flat parts. Now, if I am to rebuild the robot again, there are flat parts in the arms that I will also laser cut rather than 3D print. So ideally any flat part you could just laser cut quickly. I laser cut mine from a combination of MDF and acrylic. So it should be a 10 millimeter-thick part. So I cut it from 6-millimeter MDF and 4-millimeter acrylic.

Only because that's what I had. I'm not saying that this is the best way to do it. Maybe you should just cut it from one sheet of material. If you have the laser cutter powerful enough to cut though 10 millimeters. Now, for the robot to move, the idea or the hope, I guess, is to make it walk. To make legs for it. Now, currently our original design just has static legs. And it's unlikely that the robot will be able to walk unsupported, using those legs. Because the robot is heavy, and walking is really complicated. From a robotics perspective. So if someone 3D printed the legs to go on a robot that was not designed to walk from the start, it's unlikely that it will ever walk.

Now, currently the original design -- what Gael used is something similar to that. Where he has the robot fixed on wheels to move. Instead of making these wheels, someone from fizzPOP donated a wheelchair for the robot. And we removed the chair itself. And we have put the robot on top of the chair. Now, the wheelchairs are designed to be controlled by a controller in the arm of the chair. Not by a computer. So in order to control it by computer, first of all I had to add encoders to give feedback to the controller to tell it how fast the motor is moving. So in a wheelchair, at least in this design, it has two motors on either side, controlling two wheels, which is called differential drive. So depending on the speed of -- the difference between the speeds of either motor -- the robot will turn. So the encoders feed back to the controller, which is an Arduino. Fit inside the space between the battery and the front of the wheelchair.

It feeds back the speed, and I just bought a pulse width modulation driver that takes a PWM signal from the Arduino and runs the drivers. So I'll go back to... So that's basically it about the building. So how to operate this with ROS? Now, for the robot to move around -- I'll go back to ROS. Now, you can use the sensors on the robot, which is in this case... A Kinect in its chest. Using something other than a Kinect. It has a USB connector, but the robot was originally designed to use a Kinect. Either of them produces information called... It produces 3D scenery in a point cloud representation. So it basically tells ROS whatever is in front of it in 3D.

ROS can then use that to create a map of the area that it's seeing, and it also can identify where it is on the map. And then you can navigate through that map. It does that by planning a path through this. This is a bit of an exaggeration, because this robot would never go on a trip outside fizzPOP, pretty much. Unattended. But it does that by planning two sorts of paths. One from the first point to the end through waypoints, and then starts planning between the waypoints how to get to each waypoint without hitting anything. This is pretty much the same as what autonomous cars or self-driving cars would do. So it works in a similar way. Scans the whole area around it.

And it plans a path around it. So essentially the first thing we would be using ROS for is for Kermit. Is to move the base around, the same way as you would move a car. But also ROS can be used for -- as I said -- anything else related to robots. So the next thing, once I get the navigation working fine, the next thing will be to get ROS to move the arm, which -- what it essentially does is it calculates what positions that each joint needs to be at, in order for the hand at the end of the arm to reach its final destination. As these calculations are called solving the kinematics of the arm, which is a mathematical term for solving the positions of all the joints, in order for the end part of the arm or the end effector, or the hand, to reach the position you want to.

So that's basically it. As I said, it's a work in progress right now. We'll keep working on it, me and everybody else in fizzPOP. So if you want to know more about this robot, you can come and speak to us in the fizzPOP village, and you can follow fizzPOP on Twitter. We will be posting about updates as we progress in the build. And if you're around Birmingham, you're welcome to visit us at fizzPOP, and we can discuss how we're working on that. Thank you.

(applause)

Does anyone have any questions? Okay. Well, if you want to chat about it, as I said, we're at fizzPOP village. Behind there. Thank you!

(applause)

