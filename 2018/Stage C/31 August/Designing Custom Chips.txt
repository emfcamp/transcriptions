

>> All right. It is 20 past 3:00, and we're actually back on time in this stage. Which is really good. So thanks, everyone, for being patient. I'm very pleased to welcome Dr. James Beeley from the University of Glasgow. He'll be talking about designing custom chips and sensors and lab-in-a-pill technology. Thank you very much!

JAMES: Thank you! Could everyone hear me? I'm going to talk today about the process of designing and fabricating chips and also talk about some of the research prototype chip projects I've been designing. So I'm gonna look at the process of designing applications and integration. We're gonna look a little bit at chip foundries and processes, a little bit at chip hardware and digital hardware, a little at reverse engineering chips, and a few of the projects I've been involved with, which are capsules for doing autofluorescence and ultrasound examination of the human intestine. So the first question is: If you looked at a chip, what would you find? Okay? If you look around the edge of the chip, you will see little bondpads, which allow you to bring bond wires to a chip package or a circuit board. This is an RF chip. They're quite prominent on the chip. Inductors in the middle and to the right. These are fabricated in the metal of the chip. There's also a digital block on the left. This has been synthesized by a digital synthesis tool to fit into the space on the left of the chip. Chips are built with a number of different fabrication technologies. The most common, the most dominant, is silicon. The dominant technology is CMOS, complementary metal oxide. This is the most widely used technology, and the great bulk of digital chips. Bipolar analog is also not uncommon. There are also some more specialized silicon technologies like BiCMOS, which combines bipolar and CMOS in the same chip, used for opamps and RF work, and also BCD, used for parallel electronics. But CMOS has become the dominant technology.

The simple reason being that there are two main transistor types. The bipolar transistor. If you're using your devices as a digital switch, a bipolar transistor will draw current when it is switching. And it will also draw current in the steady state. A CMOS transistor will only draw current when switching. When it's switched on or off, it will draw almost no current. And this is really why CMOS has become the dominant technology for digital design, simply because the power consumption is much lower. Okay? And because so many -- so much of the hardware design is on CMOS, there's been a great emphasis on putting other functionality into CMOS chips. There's been a lot of interest in putting analog functionality onto CMOS chips to produce mixed-signal chips. There are also more specialized technologies. For example, silicon carbide power transistors, silicon germanium for radio frequency work and for LEDs, light-emitting diodes, there are a number of technologies. Gallium arsenide phosphide, et cetera. But there is no single technology that will do everything that you want to do, even though the whole industry is heavily geared towards CMOS. The main building block of a CMOS chip is a MOSFET transistor. It shows what you will get if you took a vertical slice through a CMOS transistor, and it's fabricated on a silicon wafer.

When you're fabricating, you're basically using a series of masks, and a series of etching processes. And you're basically implanting impurities into the silicon to create PN junctions. And in the case of the CMOS transistor, you're also fabricating a silicon gate on top. And when you apply a voltage between the gate and the source, this will cause a current to flow between source and drain. And in effect, it means the CMOS transistor is a voltage-controlled current device. And the main defining feature of a CMOS process is what's called feature size. Feature size is basically the smallest gate width that you can fabricate. In a given process. And this will vary according to process. It might be 0.5 micron in a power process, down to 7 nanometer in a state of the art let's say Intel processor. There was a nice talk at Chaos Communication Congress by Ari that went into this in more detail, so I strongly recommend you look at that.

On your chip, you've got transistors, resistors, capacitors, inductors. With interconnect, you'll have metal layers. Okay? And coming up from each of these devices, you'll have vertical metal vias, then you'll have typically between 2 and 12 metal layers. Now, your chips will be fabricated on the silicon wafer, which is typically 30 centimeters diameter. And after fabrication, the chips will be separated using a dicing saw. Now, the setup cost of a process is very high. On the order of 100,000 pounds. So if you're prototyping -- the work I've done has basically been early stage prototype projects -- using a multiproject wafer service -- basically they'll do a wafer and it will have a number of different chips in a single wafer. And this will bring the cost down to maybe 15,000 pounds. It delivers what a university research budget can afford. There's a whole range of devices you can have on chips. You can have resistors, which will be fabricated in polysilicon.

You can fabricate capacitors. Using two -- the capacitance between two adjacent metal layers. You can have inductors, which are tiny coils made of metal. You've always got bondpads to bring signals out. You can also do sensors. For example, charge-coupled device or CMOS sensors for light sensing, photodiodes, SPAD, for sensing very low light levels, ISFET, sensing pH, and there's a lot of interest in putting sensors on CMOS, because it means you can put the sensor and the processing electronics on the same chip. A lot of the old digital cameras use CCD, charge coupled device. Charge coupled device needed a separate chip to address and process signals. The CMOS sensor allows you to put the imager and electronics on the same die, with a resultant saving in cost and size. You can also process things -- for example, optical field on top of the chip. So I'm gonna talk about the design process.

This is what I do for a job. There are really only three major dominant manufacturers. There's basically Synopsys, Cadence, and Mentor Graphics. Because it's quite a specialized process, there aren't a lot of companies. The software is very capable. It's expensive. It can leave a bit to be desired in terms of usability. Open Source support is very limited. There is Magic. This is quite an old and limited Open Source package. But basically pretty much everyone will use a commercial package for one of the three major manufacturers. Okay? One side obviously is the design software. The other side is a design kit. This is supplied by your chip manufacturer. Your chip foundry. And it's specific to the chip design process. Okay? So they will basically give you -- they'll give you a set of simulation models. They'll give you digital standard cells for digital synthesis. They'll give you design rules, because each process has a set of rules in terms of things like gate width, track width, spacing between structures. And these are manufacturer rules that have to be adhered to pretty strictly. If you don't meet these rules, they won't even try and fabricate your chip. Another interesting thing is that a lot of the devices are parameterizable. So you could have a transistor and define the width-length ratio where you define the gain, or you have a resistor where you define the resistance.

The other thing that you can often pick up from other manufacturers are: IP blocks, intellectual property blocks. Because of the expense and complexity and risk in designing chip hardware, there's a strong emphasis on design reuse. In other words, if you've got hardware that works, a sub-block that works, you would tend to reuse that. And there are many companies that are actually selling validated and verified third party IP blocks. Again, these can be parameterizable, so you might, for example, buy a ROM or RAM block for a processor, and when you buy it, you would specify the RAM depth, the ROM depth, and data bus width. There are really two kinds. You've got hard cores. Hard cores are specific to a particular chip process. You also have soft cores. They will come in a hardware description language, and you can put them through your synthesis tool and you can synthesize them into your own process. So there are all sorts of blocks -- for example, ADCs, digital-analog converters, opamps, buffers, phase-locked loops. There are various bus cores. PCI express, UART, which again will be preverified. You can even buy an entire process. This is ARM's business model. ARM don't make processors. ARM sells processor course to third parties who integrate those into their own chips along with all the functionality.

So if you want to design the chip, your starting point will be a specification. You define what you want your chip to do, your power budget, printout, et cetera. And that will take you onto a particular fabrication process. Then you'll partition your design down, you'll partition it down into manageable units, into analog blocks and digital blocks. And then you'll spend a lot of time simulating and verifying. The problem with a chip is... With a circuit, you can pull out your craft knife and soldering iron and rework it. If you write a piece of code and it's buggy, recompile it. You can't do that with a chip. In chip design, you spend a lot of time in verification, a lot of time in simulation. Analog simulation, digital simulation, mixed-signal simulation, design route checking. So before you submit a design, you want to be very confident that that design is valid and is going to work.

And in the real world, you often go through multiple iterations. It will often take you quite a few iterations to get something that actually meets spec. So I don't know... How many people here have done PCB design? The analog entry process is very similar. You have a schematic tool. And you have a library of transistors, resistors, capacitors, et cetera, which will supply their part of the design kit. And you'll basically enter that in your schematic tool. Cadence Virtuoso, et cetera. And you simulate each of the design tools -- it will incorporate basically a SPICE-type simulator. Synopsys does Hspice. You will do a transient where you define inputs at times and you get a wave form output and look at that to see if it meets spec. You can do frequency sweeps, you can also sweep over a range of temperature, because obviously device behavior will vary with temperature.

With process tolerance. And with supply voltage. And you can also look at things like phase and gain margin for stability amplifiers. And again, you'll go through iterations -- once you have something that meets spec, then you move into the layout phase. So you've basically got an analog layout tool. So basically in your schematic tool, you'll basically pick each device. The layout tool will generate an appropriately-shaped transistor, resistor, inductor, et cetera. You then have to manually place them. And you also have to... When you place them, you have to consider carefully signal integrity. For example, keeping noisy digital circuitry away from sensitive analog circuitry. You will then have to manually run wires on the metal layers. Vias and wires between those devices. Then you can do a layout versus schematic check. Okay? That will check that your layout matches the schematic. You have to do a design rule check. That checks that the layout complies with the design rules. Okay?

The other issue you have is parasitics. You've so far simulated transistors with ideal connections between them. Okay? You have now -- now you've done a layout. You have now added extra metal -- wires in the metal layer. These will bring in stray inductance, capacitance, resistance. And these will have an effect on RF circuits. You run parasitic extraction, this will rerun your simulation model and add additional conductances and capacitance. So you resimulate with parasitics, and once you've done that... Again, iterate a few times... You have a valid analog block. The digital design process for anything but the simplest designs is built... It's built around hardware description languages. So you're basically writing a programming language description of the functionality you want from your chip. So common languages are VHDL, Verilog, SystemC, SystemVerilog. You're basically coding up a description of functionality of things like counters, buses, addressings, state machines, et cetera. Now, these languages, unlike functional coding, they're inherently parallel, because you're coding up a bunch of functions in hardware that will operate simultaneously. The other thing you need to be careful about is that each of your synthesis tools only implements a subset of Verilog VHDL. You can code something in C or Python, write it a bunch of different ways, and it will work. Verilog or VHDL, you can code it in syntactically valid VHDL, but you really need to follow Cadence or Synopsys's method of coding. An important thing is a test bench. A test bench is basically a top level. You basically instantiate your design as a module. The test bench provides a set of inputs for testing. Which you use in simulation.

So once you've got syntactically valid VHDL, you would put that and your compiler and your test bench into a simulation tool like VCS or NCSim. This will give you a waveform output. You would define your input signals, define your clocks, define your data buses. This will give you a waveform output. This allows you to verify that your code is functionally correct. At this stage, it doesn't include any timing delays. Again, iterate this multiple times until it works. Okay? Your next step is synthesis. Once you have a valid VHDL description of your circuit, the synthesis tool -- this will convert that into a net list of gates, because the gates are process-specific. The gates will be provided -- gates or blocks -- they will be provided by your ASIC foundry. So you'll give your synthesis tool a Verilog or VHDL netlist input, give it timing information for the gates, and constraints. You can constrain power. You can say this pin is a clock, and it works at 50 megahertz. This has to output a delay of not more than 5 microseconds. You give it those constraints. The synthesis tool will attempt to meet those. And again... You may need to iterate this a few times.

And assuming synthesis is successful, it will generate a netlist, but you now have a netlist of gates, provided by the ASIC manufacturer. Okay? You've also got a standard delay file, SDF. This provides... Basically provides system time delays. In other words, the propagation delays within each block or gate. Okay? Now, this... Because it requires iteration, the process is heavily command-line driven. Okay? You can see a graphical interface there, but a lot of the commands are... A lot of the functionality is command line based, and this is so you can script it. Because, again, you often go through many iterations, so the whole thing is scriptable, using TCL. So that will give you a script so you can rapidly iterate whenever you have to go back and make design changes. You've now got a netlist, of gates and timing. You'll put this into a place in route tool. For example, Cadence Encounter. The place in route tool -- it will take that netlist and physically lay it out on the silicon. So you'll define the boundaries of the digital block. Think of the second slide I put up. There were digital blocks that can be shaped to fit around other devices. So you determine the boundary of the digital block. You set up power and ground rings around it.

And you'll import your netlist and again give it timing constraints, you'll define which signals are clocks, which are resets, which are asynchronous. Then the place in route tool -- it will autoplace those cells in rows. It's basically row-based. If you're to look at a digital chip very closely, you'll see row, row, row of chips. It will autoplace. It will then generate a clock tree. Okay? The clock is... The clock is basically the source of synchronization for the circuit. And the goal of clock tree generation is to minimize the skew or the time difference between different clock signals within the chip. So basically it'll place the clock buffer -- it will basically prioritize that first. Then you run the autorouter. The autorouter will attempt to autoplace tracks. Which will interconnect with cells. Then you run a static timing analysis. This will basically check each path through the system and check it meets the constraints. And if it doesn't meet the constraints, the tool can to a certain extent fix timing violations. It can insert buffers into clock paths or signal paths. But again, if you have major timing issues, you may have to go back and reiterate the design. Okay?

Assuming you get through place in route successfully, again, you run verification, you would run design rule checking, then it will generate an output block, and Cadence, for example, in OASIS format, which you can import back into Virtuoso. It will give you an output netlist, which you can use for simulation, and output timing signals. And you can then do a post place in route simulation. It means you can resimulate with gate delays and interconnect delays. And again, you want to check that meets your specification. And if not, again, reiterate. Your next step -- once you have valid analog and digital blocks, is chip assembly. Okay? You will basically layer the complete chip. You'll have bondpads. Analog input and output pads. You'll basically place a pad ring around the edge of your chip. You will place your analog and digital blocks in the chip, again, taking care over signal integrity. Taking care to keep digital signals, which are noisy, away from analog signals. Again, you will manually wire tracks to connect those blocks together.

Again, you will do a lot of... There will be a lot of time spent doing design rule checking, versus schematic, parasitic extraction, mixed-signal simulation, et cetera. This stage is -- you're simulating the whole chip. This stage is slow. You're often rushing to do this, to meet a chip deadline. Once you have a valid chip, the process -- this was done years ago. It's still referred to as "tape-out". So you'll submit a GDSII file to your chip foundry. To your manufacturer. You'll then wait... Certainly in our case, wait several months. You'll get a small number of chips back and spent a certain amount of time testing. A chip on its own is not a lot of use. A chip needs to be bonded to a circuit board or into a package. The bulk of chips will be wire bonded into a package. It will be a bowl grid array or pen grid array package. You'll have bond wires made of aluminum. And these will be bonded to a bond head. If you look on the top right, little bond wires are bonded from the chip bond pads onto bond pads on the package, and these pads on the package, these in turn are connected to pins.

Now, traditionally, the traditional package is a package with pins at 0.1 spacing. The limitation is you can have a limited number of pins, and the other is that you have stray inductance and capacitance, which tend to impact on radio frequency surface. A lot of them will use ball grid array. In this case, you have a chip mounted to a substrate, and you'll have solder balls that are ball grid bonded to a circuit board. You can have multiple substrates or multiple chips on the same package. As I mentioned earlier, no one-chip process is really suitable for all functionality. On the bottom right is a New Pixel. This is a programmable multicolor LED. It was on the EMF badge from two years ago. If you look closely, you can see they've got four separate substrates. These are three LEDs in different colors. The top chip is a CMOS chip. The CMOS will basically take a serial input command. It will then drive the three red-green-blue LEDs to give the color. There's a whole industry devoted to reverse engineering of chips.

Whether that's hobbyists, people looking for patent violations, figuring out what the competition are doing. Most chips are packaged in resin. To get it off requires nitric acid, which I wouldn't recommend for safety reasons. Beyond that, once you've actually exposed the chip, you can then strip away the individual layers step by step. Again, if you want to look into this, a couple of nice websites. Righto.com. Zeptobars. They've got a couple of nice pictures. If you want to look at chips yourself, there are devices -- this is a power transistor. You can get them on eBay. It will come off with a hacksaw or dremels. If you feel like decapping a chip yourself. This is interesting. Fake chips. This was something that turned up on the Zeptobars site. They were looking at Nordic NRF... This is basically a UHF RF tranceiver. The original chip is about $10. They came across a fake, with a bootleg copy of Cadence. They were able to reverse the whole chip. Bunny Huang has many thoughts on this. Here are some projects I've worked on.

This is the fluorescence imaging capsule. This was a project I worked on at Glasgow University. You may have come across white light imager capsules. It's basically a capsule you swallow and it has a camera, LED, and lets you image the entire intestine. It's used to image disease. And it will cover parts of the intestine that endoscopy won't cover, because endoscopy will only cover down to the stomach, below the stomach, and the large intestine. Endoscopes won't cover the small intestine. Autofluorescence -- if you illuminate intestinal tissue with blue light, it will fluoresce green. You get weak fluorescence. This fluorescence lets you see early signs of disease that you're not going to see with white light. So we developed a prototype capsule to do fluorescence imaging of the intestine. There is a well proven fluorescence endoscope, but it only goes down to the stomach and duodenum. So basically we did a 32x32 single photon avalanche array, and we basically integrated it into a miniature capsule. We integrated it with an FPGA for control and an 868 megahertz wireless link. And we have validated this on intestinal tissue of a pig. I had to go to a slaughterhouse to pick up pig intestinal tissue, which is kind of fun. And this is the fluorescence imaging... We did this in a 0.35 micron high voltage process. High voltage in the ASIC world means anything above 5 volts. The chips are 3.7x3.7 millimeters, you've got a single photon avalanche diode array. It will basically have a pulse each time it gets hit by a single photon by autofluorescence. We've got a charge pump that generates 37 volts from a 3 volt hearing aid battery. And this draws about 1.8 milliamps on average imaging, 1 frame per second. And the capsule runs for about 12 hours, which is ample to work through the human intestine.

Another project I worked with is the Sonopil. The idea is to do ultrasound imaging below the surface of the human intestine. You can look from outside the body with ultrasound, 2 to 5 megahertz. It will let you see through the whole body. For example, the ultrasound used for imaging pregnancy. It doesn't let you see much detail. If you increase frequency, you get less depth, but you have much greater detail. So the goal is to put 30 megahertz ultrasound inside a capsule to see a few millimeters below the intestinal surface. So the basic idea is we would have 8 ultrasound drivers, a 32-element receiver array, data acquisition, embedded processor, and ADC on chip. Okay? So this is the chip we designed. This is done in a 0.18 micron high voltage process. We've got our own chip processor, data acquisition block, 32 low noise amplifier receivers, for acquiring data from the receiver array. We've got ultrasound transmitter, and we did this -- we did this in an AMS process. This is currently bench testified with transducers. It's showing good signs so far. I've been given hints to finish quickly. So this is just one more project. This is a multicorder. The idea in this case was to put multiple medical diagnostic devices, benchtop devices, on a single chip.

A single hand held disposable chip, basically looking at pH and spectrophotometers, to look at metabolites, which are markers for disease. And this basically had a 16x16 or 32x32 array, SPAD for low light imaging, pH, and photodiode. Okay? And this chip basically had enzymes bonded to the top, and it's actually been proven with two different processors. One was an enzyme which creates a color change in relation to cholesterol level. And the second, which was a pH change in relation to blood glucose. So this is basically a research prototype. To demonstrate a small handheld device that can be used for disease diagnosis. I've been given more hints to finish. So these are just a couple of sites you might look at, for further reading. If you want to look at more chips. Thanks, guys. We might have time for questions.

(applause)

>> I'm afraid we're probably not going to have time for questions. Where might they find you if they want to come and ask you questions?

JAMES: I'll be outside.

>> Outside. Probably towards the bar.

JAMES: I'll be over there.

>> That way. Thank you. Please thank James very much for this fantastic talk. Thank you!

(applause)

