       
      Adventures in retrocomputing
      
      Andrew Jenner
      
      >> Welcome to stage B, the next speaker is Andrew Jenner.
      ANDREW: Thank you.  This is a story about absurd lengths I went to get an old game running on new computers.  Like many of the best stories, this story starts when my parents brought home a PC, a home computer into our house for the first time.  It was a PC1512, pretty good PC for the time.  It had an 8-megahertz 1886CPU, half a megs of RAM and 16 color graphics.  Resolution, 640x200.  A PC speaker that made music that sounds pretty great in today's ears.  And it came with a graphical user interface and a mouse, which was the hot new thing at the time.
      It came with a few bits of software, but we were looking around for new things to run on it.  And how got hold of a disk full of pirated games.  There were a few fun game on this disk.  There was Willy the Worm and a Frogger clone called Hopper.  But our favorite game to play was this one, Digger, by Win Loss software.  Didn't know about it, didn't come with introductions.  We had to figure out how to play it as we went along.  And this game had this sort of fantastic sort of cartoony graphics.  It had music that was a little more sophisticated than the music in the other games.
      Programmers were clever enough to be able to make the notes in the background music actually change volume over time.  So, they nicely shaped with envelopes.  Because we didn't know how to play the game, it was some time before we figured out that the F1 key fired a fire ball.  And you could kill the enemy.  It was much easier to play once we figured that out.  And finally got rid of the old machine and upgraded to a 486 which came with super VGA graphics.  But unfortunately, Digger did not work on this machine.  Programmers had programmed the machine at such a low level they were programming the individual registers on the CGA card and VGA is not compatible to CGA to that extent.  If you try to play Digger on a VGA or superVGA, the display is corrupted.  It's completely unplayable and far, far too fast because all the timing in digger was done just by counting CPU cycles.
      If your CPU is actually, it's twice as fast, the game will play twice as fast.
      So, a number of years passed, and I had an idea that I wanted to fix this to make it playable on modern machines.  And I actually went to the  the first thing I did was actually I reverse engineered the graphics out of the executable file and redrew them in VGA resolution.  Just for fun.  I didn't think I would actually do anything with them at the time.  And then in 1998 I finally got around to decompiling the entire game back to the C code.
      And I believe this is the first time that somebody had remastered a game in this way.  I've heard of a few other projects since.  Similar projects with other games.  But the  as far as I know, I was the first person to do that.  And if you have any information to the contrary, let me know and I'll retract that.
      So, once I got it back to the C code, I was able to add the VGA graphics that I had drawn into it.  I added sound blaster sound.  I added a few more features.  Game recording and playback so that you could show off your high scores to your friends.  Mode where two players can play simultaneously and either cooperate or fight each other, depending on how you want to play it.  I added the ability to redefine the keys which are kind of useful for people whose keyboards didn't work very well with the keys that it came with.  And an exit button.  The original Digger, to exit the game, you actually had to reboot the entire computer.
      As a number of games did in those days.  There was one part of the game which I never got exactly right.  And that was this screen.  When you get a new high score.  The  the original Digger would hammer this CGA's palette registers to change the colors of the letters on this screen in a sort of shimmering fashion.
      And because the computer that I had originally played digger on was not the same speed as the computer that Digger was written on, I didn't know exactly how this screen was supposed to look.  So, I wasn't able to reproduce it properly.  So, I just made it a sort of guess at what  at how I thought it should look.
      But it was  it always kind of bothered me that there was this particularly visible thing that shows that  that it was  that the remake was inexact from the original in that respect.  I guess the speed of the game overall was also inexact, but that seemed less of a concern to me at the time.
      Now, the answer to this kind of problem is, of course, emulation.  The emulator is a program that will take a modern machine and teach it to behave like an older machine.  And there are a number of emulators for emulating old PCs.  I've actually contributed to a whole budge of them over the years.  Adding support for various games and bits of hardware that did weird things with them.
      The mess with the multiple emulator supersystem, now part of the main multiple machine arcade simulator is extremely thorough in the number of machines that it emulates and the accuracy at which it emulates them.  There's Dustbox, familiar for anyone who runs DOS software.  It can access the drives on the host machine.  And there are a few others that have  that other people have written over the years for one purpose or another.  Including a couple that I've written myself.
      This is an emulator that is in process.  It's sort of a longrunning project.  It's an emulator that I hope you can reconfigure dynamically.  You can write a configuration file that specifies exactly what hardware you want in your emulated machine and it will figure out how to wire it up for you.  If you want a sound chip from a Commodore 64 and place it in a micro, you could do that.  And there's a simple basic emulator that I wrote to test a compiler that I was porting as part of the GCC new C compiler targeting the 8086.
      And none of these have an accurate CPU cycle timing.  The reason for this is that the exact timing of the  of the  of how long open instruction takes in terms of the number of chock cycles it takes is not documented anywhere.  There are documents online that give best case timings for these  for each instruction.  But the  there are a number of reasons why any particular instruction might not take  might take longer than the optimal time.  A lot of ways in which the other parts of the machine can steal cycles from the CPU.  I will talk about more of that  more about that in a minute.
      In 2011 I finally got myself an original IBM XT.  It was built in 1984, I believe.  And as far as software is concerned, it is pretty much identical to the original IBM PC from 1981 that is sort of the granddaddy of all of the X86 machines that have taken over the world since.  Pretty much.
      So, this machine has a 4.77-megahertz Intel 8088CPU.  It's an 8bit  8bit bus.  But 16bit CPU internally.  The machine has 640K of RAM.  I actually got quite lucky.  It was a machine I bought on eBay and it came with a bunch of expansion cards.  Including a RAM expansion to take the RAM from the 256K that was on the motherboard all the way up to 640K which as the saying goes, should be enough for anyone.
      I have one five and quarter inch 360K floppy drive for it.  I have some other floppy drives that I keep meaning to fix so I can have the dual floppy system that was very desirable in the day.  I also bought a CGA graphics card for it so that I could play all the CGA games just the way they were meant to be.  So, CGA graphics, it's a little less sophisticated than in the PC1512 that I started with.  In the 640 resolution, you can have two colors on screen at once, or four colors at half the resolution.  But if you plug it into an NTSC monitor or an American TV set, you can actually get all 16 colors on screen at once.  At a resolution of about 160x200.
      When I got this machine, it  it didn't have a keyboard.  It didn't have any working floppy drive or hard drive.  And the only graphics card that it came with was not compatible with the one monitor that I had for it.  So, my first job was to try and figure out how to actually load code on to this machine.
      Now, the  back in those days, when you bought a PC from IBM, it came with the  a great deal of technical documentation.  It came with these  the schematics of the entire machine.  And also, the  the assembler listing of the bios.  The ROM chip inside that actually boots the machine.  And looking over these assembler listings, I noticed that IBM had left in there a little something that they used in the factory for testing.  For testing the machines as they came off the assembly line.  A little piece of code that looks for a particular byte coming in over the keyboard port.  And if it sees that byte, instead of the normal byte that says, hey, I'm a keyboard, then it will know that it's not actually a keyboard that's connected to the machine, but IBM's internal manufacturing test device.
      And what it does with this test device is it just loads a stream of bytes over the keyboard port.  Dumps them into memory and then when that stream is finished, then it just goes and runs them.  So, it's a really good way of just getting code on to the machine really quickly.  I started off actually just by plugging an Arduino into the keyboard port to get code on to it.
      I have since built this little circuit which is basically the same thing.  It's basically an Arduino.  It's a microcontroller running at 16 megahertz.  The irony that this is quite a bit more powerful than the PC that it's plugged into is not lost on me.  As well as the Arduino, this has got a pass through for the actual keyboard.  So, it plugs into the keyboard port and the actual keyboard plugs into this.  And it has a serial port to plug it into a modern machine for transferring programs over from the modern machine on to the XT.
      And there's one more connection here, this little red wire, that you can see.  That goes off into the corner.  That's actually spliced into the XT's power good line from the power supply.  So, when the microcontroller pulls this line low, it resets the entire machine.  Does a complete hard reset and then in a second or so, it's back at the part of the bios where it can  it's looking for that byte from the keyboard port.
      So, rather than  some of you may remember that PCs in those days would go through a very long memory test when they booted up.  They would count up for each kilobyte of RAM in the machine.  So, if you have all 640K of RAM in an original IBM XT, it takes a couple of minutes to boot up.  But the manufacturing test routine happens before that memory test.  So, you can actually get the machine running a new program that second this way.  It's much quicker to iterate when you're developing software for it.
      I've taken this device and it's connected to a modern PC in my office.  And that modern PC is running an Apache web server.  And there's some CGI scripts that I wrote myself.  Anyone anywhere in the world can load code on to this XT by using this web interface.  They have org/XT server.  So, the screenshot you can see here is just a web browser that I've sent as a post request, a floppy disk image, a 360K floppy disk image containing the docs.  And also, that, it just prints itself, so you can see how that works.
      The XT server does not yet support key strokes coming from the  from the web browser and then sending those over to the  over to the XT.  That's something I'm  I hope to add at some point.  But it's useful to  for noninteractive things you can write a program.  Stick it on a disk image.  Send it to the XT server.  I can get the results back and so this is really useful for emulator authors who want to run experts on the real hardware to see what the timings are for various things.
      And none of them took me up on it, though.  So, I was left to figure out these cycle timings myself.  So, this is the target that we are trying to make a cycle exact emulation of.  The Intel 8088 which was the hot new thing in 1979.  It uses a 3000-nanometer process.  Compare that to I don't know what they're down to today, 15 nanometers, 10 nanometers.  It has 29,000 transistors, compared to billions in today's CPUs.  Registers, 16 bits.  A 20bit memory space.  It can address a whole megabyte of RAM.  Normally 640K of RAM and the other 384K is for ROM and things like that.  The CPU and micro coded internally.  While it's running your program, it's also running its own little program and its own special purpose instruction set.
      The sort of blue rectangle you can see in the corner of this photograph is actually the main ROM which holds the  holds the microcode.  It's 504 instructions, each of which is 21 bits.  So, my purpose in building this emulator wasn't to run this original microcode program just to get something with the same cycle timing so that it would be indistinguishable to software that is running on the actual PC.  The microcode instructions themselves I haven't actually got a dump of them yet.  This photograph is high enough resolution to be able to see the individual transistors, but it's only the top layer.  And I don't want to mess about with fuming nitric acid or whatever you have to do in your house to take the photographs and reverse the engineer the chip at the gate level as some have done with the chips.  So, I decided to approach it just by trying to reverse engineer the chip from the outside.  Run code on it and do timings and figure out the  figure out how to works that way to  for fidelity.
      Here's a little slide about the architecture of the Intel 8088.  The top half here is the bit that communicates with the bus.  And then the bottom half is the actual execution unit which does the  it runs that microcode program.  So, the execution unit is, you know, adding your numbers together or multiplying, you know, whatever you've asked the computer to do.  And then the top part gets program and data in and out of the CPU to the memory and other devices on the machine.
      And the fact that the  the fact that these two parts run sort of asynchronously and either one can be waiting for the other at any point in time is why the timing of this chip is so complicated and it hasn't been done before now.  Not only do we have to know how long each instruction takes overall, but also where in the execution of that instruction it  it asks the bus execution unit to get or put a value to the bus or gets a byte from the prefetch queue that  the 4-byte prefetch queue in 8088 which queues up bytes of the instruction  of the program.  The instructions that the execution unit will be running next in order that the  the execution unit won't have to wait for the bus interface unit for too long.  And that does speed things up quite a bit over similar architectures.  But it take make the timings a lot more complicated.
      On the  this diagram that shows the  shows auto pins in the chip, you probably can't read it.  The text is small.  There are two pins, QS0 and QS1 which actually show the status of the prefetch queue.  And they show  for each cycle that the  that the CPU is executing, it shows whether the queue is being emptied, whether it's the first cycle of an instruction, whether it's the subsequent cycle of an instruction or if it's just  if it's just idle.  And the reason these pins exist is for the 8088 or 8086 to be able to interface with the 8087 floating point code processer.  The floating point code processer actually runs alongside the CPU.  Monitors the instruction stream.  And if it sees an instruction that is a floating point instruction, it interrupts and hops in and does its thing and then sends the result back to the CPU over the bus.
      So, I wanted to be able to read these key status pins along with everything else that's going on in the machine, so I could see what the queue is doing at each point in the execution of these instructions.  So, I ended up building this little ISA card.  Again, it's based around the 80 mega 328.  I like that chip.  And this time rather than at 16 megahertz like an Arduino does, the clock is actually taken from the clock on the ISA bus., it actually runs at 14.318 megahertz.  14 times the NTSC color carrier frequency.  And as well as the microcontroller, it also has a serial port to get the results out to a modern machine.
      And the only other thing on the board is these multiplexes.  So, there's only so many I opens on the I 308.  And I wanted to sample a lot of pins.  Not just on the CPU, the 40 pins on the CPU, but also the pins on the ISA bus as well and a few other things that I've since added.  If you look inside my XT now, there's wires going from this board to all over the motherboard, so I can sample various lines.
      So, the way that this bus sniffer works is we run the same program multiple times.  Taking care to ensure that each time we run it all the timing is exactly the same.  So, the machine is put into a known state, run program.  Something it finds.  Once for each set of pins that we want to sample.  And it works really well.  This is a dump of the output of the ISA bus sniffer.  The columns on the left show the actual raw data from the  that's coming over the serial port from the bus sniffer card.  On the right there's the  that's been done on it.  So, it shows exactly which instruction is starting on which cycle.  And it shows the  the bus access is the reads or the writes to the bus that are occurring at each cycle.  And also, when the  when the machine gets interrupted for a DMA transfer, which happens 64,000 times a second for dynamic RAM refresh, that's all shown in the diagram as well.
      Now, a little side quest.  In 2015 I worked with some friends on this demo scene demo, 8088NPH which we presented at the demo party in Germany.  And it blew everyone away with what we were able to  able to coax these old 8088 CGA machines into doing.  We read a bunch of effects that only work on IBM PCs and XTs.  Because like Digger, they required the machine to be cycleexact.  And we also got  we also managed to coax the CGA card into making about a thousand colors rather than the 16 that it's capable by using and abusing the NTSC composite color system.  We also got it to play fourchannel music on the PC speaker.  Which, again, is all cycle counted.  So, if you try to run that music on a modern machine, it will sound very highpitched and fast like a record played back at the wrong speed.
      So, a nice thing is that now we have an incentive for emulator authors to try to get there, lambs to be cycleexact so they can run this demo the way it's supposed to be.  Because we didn't have a cycleexact emulator when running the demo.
      I'm still working on a cycle exact emulator.  I call it X TC, XT cycle exact.  What I have at the moment is a program that generates a very large number of test cases.  It tries to test the timing of each of the 256 possible op codes that the CPU can execute.  Some of the things are not even valid op codes.  I'm even testing the timing of illegal instructions.
      Where the operand to the instruction can make a difference to the timing, I'm testing all combinations of operands as well.  And also, the state of the prefetch queue and the bus can make a difference.  I'm testing each possible combination of those.  There's a very large number of possible situations that the machine can be in.
      Once we've generated all these test cases, we batch them into chunks of 64K at once.  We send them over that serial link to the microcontroller to run them on the XT.  And then if any tests are not  if any of those test cases turn out to have different timing on the real hardware as only emulator, then it will run the IOC bus sniffer to get a trace of what happened on what cycle on that.  And I can compare with the equivalent instruction trace on XTCE and see where the emulator is diverting from the real hardware.
      And so, by iterating through that process a lot of times, about 550 of the tests  of the test  those automaticallygenerated test cases have at some point found a bug and timing problem in XTCE.
      And  but it's now got to the point where millions of these tests are now passing and it's able go for days at a time without hitting on the tests.  In fact, the limiting factor right now is not the  the time it takes to run the tests or bugs in the emulator.  I'm now running out of memory on the modern machine to actually hold all the tests.  So, I think what I'm going to have to do is have the  maintain two versions of the  of the emulator in the same program.  So, one  one will  is the one that's actually on the test.  And one is the last known good.  Last known good version of the emulator with the correct timings that they were known to be so far.
      And then I can compare those two and then when we run out of  run out of tests that  that we have last known good results for, then we can run them on the real hardware.  As well as the timings of the  the bus with the way that the bus execution  the bus interface unit and the execution unit interact, another problem that I had is the fact that the multiplication and division routines are actually fairly complicated little bits of microcode.  And these  these instructions actually take different amounts of time.  A different number of cycles depending on what numbers you're multiplying together or dividing.
      And here's a fun little picture they made of  that shows how the  the timings change depending on what  what numbers you put into these instructions.  So, on the left is 8bit multiplies.  So, you've got one number that you're multiplying together on the X axis.  One  the other number on the Y axis.  On the color at each point, it corresponds to the number of cycles that multiplication takes.  And similarly, for division over here.  The multiplication one actually wasn't too difficult to figure out.  It turns out to be one cycle for each one bit in each of the operands.  And a few other things to do with whether a cycle  if the result overflows.  And some cycles if you're doing sine multiplication, depend on which of these four quadrants you're in.
      So, yeah.  The multiplication one wasn't too difficult to figure out.  The division one took me ages.  I thought I knew how to implement division algorithm in the same way that a CPU would do it just in terms of compares, additions, subtractions.  But no matter where I put the delays in this  in my own division routine, I could not get the timings to line up.
      The  fortunately I found a patent that Intel had filed about the implementation of the 8088 and 8086.  And this is an extract from that patent that actually shows the division algorithm that  as it is implemented in the microcode.  And the patent is terribly written.  A whole lot of terms in it are never explained anywhere.  There are mistakes all over the place.  But after a lot of head scratching and looking at this patent and trying to figure it out, I actually figured out how this division routine works.  And we implemented it.  Myself in C++.  And I got the timings to actually work out.
      So, although I'm not a fan of patents in general, this one actually works out pretty handily for me.  And in fact, the algorithm as implemented in the microcode is a bit cleverer than the one I implemented myself.  It actually manages to do the division with fewer temporary registers which are very important if you're running on a CPU with a very small number of transistors and internal registers.
      I'm still working on XTCE.  There's still a few more  a few more bits to do before I can call it finished.  A number of  a number of situations where the  we have the instructions.  If you're using multiple prefixes at once, there are situations there where that isn't defined.  Situations to do with hardware interrupts.  If a hardware interrupt comes in, a device needs an interrupt servicing.  Then whereabouts in the execution of the instruction does that interrupt actually occur?
      And then the  I want to use these 550 or so tests that ever fails to make a torture test for other emulators, so they can see what torture they are.  And the rest is implementing the machine, CGA card, keyboard, speaker, mouse.  Host, reading files off your hard disk would be very useful indeed.  And fixing up the climbings of the other peripherals, the timer and the interrupt control and the DMAs and the other peripherals.
      So, that's the end of my talk.  There's a new few links here to some of the projects that I've talked about.  All the code for all of this is on GitHub.  So, I'm afraid it's all a big mess in one repository.  You'll probably have to email me if you want to find something specific in there.  That's it.
      [ Applause ]
      >> Any quick questions?  Anyone?  Okay.
      AUDIENCE: So, except for your demo scene code and the Digger game, how sensitive are most games to the timing of the XT?  Most games are not that sensitive at all.  Even games that were written to be only tested on that particular CPU at a speed that is governed just by the speed of the CPU, there were a number of games like that.  But people played them on faster systems.  They were just more difficult.  So, it's kind of an academic exercise to  to actually make this cycle exact timing.  It's not for running realworld software.  I'm hoping that by implementing this emulator, I will sort of spur the development of some software that  running on these old machines that is cycleexact that does require that cycleexact timing and can therefore push the machine much closer to its theoretical limits than it would do if you are relying on other parts of the hardware, the timer interrupt and so on to do your timing.
      >> Thank you, Andrew Jenner.
      [ Applause ] that's it for talks on stage B.  If you could just  if everyone could move chairs to the side.  Just move your chair around.  That would help with the next up.  Announcements.
      Amplified music needs to stop at 11:00 tonight.  That's very important so that we don't upset the site.  And the bar still wants volunteer shifts.  Thank you. 
