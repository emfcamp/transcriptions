      Lightning Talks
      
      >> Hello.  Good morning, everybody.  Welcome to Saturday lightning talks.  We're just going to start up in a minute.  Just a quick announcement.  We are in need of volunteers for all areas.  And if you have time to volunteer, please head up to the volunteer tent after the great lightning talks, obviously.  And you will be tasked with doing AV or odd jobs or something.
      Okay.  So, first up we have  is the speaker here?  Okay.  So, last up we have CoderDojo.  All things, Andrew Mawr?  Now.
      >> Okay, hey, everyone.  This is my Android and I'm going to show it to you.  If you like this kind of stuff, some techniques you can use to identify malware at run time, different from what we normally do.  These are headlines.  Malware is a problem in the Android space.  It's not just a couple infections here and there.  It runs in the scale of millions and hundreds of thousands.  If you own an Android device, you have probably been affected at some point.  If you think you haven't, you just don't know about it.  Typically, we look at malware in a couple ways.  I won't go into the technicalities of these.  But generally, they allow for analysis of artifacts, APK, look at signatures.  Reputation, one of my favorites which is kind of that screenshot on the right.  A free torch app.  And especially on the App Store, a lot of the apps are saying this is free or free Minera mining, that's probably going to end bad.  And memory, but that's after postinfection.  What are the short comings?  If you have evolved, static analysis is hot, and you have to note Android run time quite well, which is quite hard.
      I find it hard, you can't run cuckoo on your phone.  But the currents analysis techniques only show a subset of what the malware does.  It's really good at hiding what it does.  And at the end of the day, it shows you 100% of what is a nasty piece of malware.  We want to look at the memory at run time.  This is a bad joke in a way, but if you really want to torture yourself, look at prop PID maps.  That's where memory lives for a particular process in Linux.  Android is Linux.  If we want to hit ourselves, we can look there for objects.  And this technique basically we're going to do is look at objects because every piece of malware makes useful objects.  They're not making use of the  if they were, that would be cool.  But they're not.  And we want to look at what objects have a run time for a particular process.  We can look at maps or GDB and look at it manually or an awesome tool, Freida.  I highly recommend you look at it.  It's a great instrumentation framework and allows us to look at a process at run time while it's running on the device and you can look at everything from system calls and more interestingly looking at the memory of a process.  So, for example, technique is to back up applications for the interpreter.  It's quite funny if you want to troll your friends, if they have apps from the app store.  And two things, ATV connection.  You want to basically look, does this app inject additional functionality at run time, a common technique.  And does it have communication?  Most of the time malware will make use of these two techniques and this is often missed by static analysis because in functionality, it's important.  You will not see the static analysis.  You have to invoke the end run time to see this actually happening.
      So, I won't do any live demos and I was lazy.  I got some links here to some videos.  Remember on the computer.  They just did it automatically.  So, basically what's happening here, we're going to do a standard infection, this is nothing new.  This is typically what a computer looks like.  We have backed up the application with what I was talking about earlier, the interpreter.  It's legit application, it will function as Twitter.  And this shows we have a session.  And remotely we are controlling this device over here.  And from the attacker's machine I am going to take in the moment a screenshot of the application and get the person's password and this infection makes use of a bunch of objects.
      To actually perform this kind of functionality, this is my evil machine over here.  And if we open up that picture, we will then see the screen of the device that we had infected.  Now, that's all fine and dandy.  And not really that interesting.  Been around for quite some time.  But some of the issues that we have is how do you analyze this malware to see that it's actually doing that?  So, I asked myself that question.
      And, again, another link.  There we go.  So, we've got the same infection.  And I built something called Apkek, if you are familiar with Dutch, you know what I mean.  And what we do now is use a tool called Freida.  We hook into the process.  Analyzing the system.  These are system processes running over here.  I built a client for Android.  It's permitted with DDoS.  I appreciate some help on that.  We are basically hooking into the process of the application and we are going to say, give me all the objects that this process is using.  And from those objects, I can then look and see which ones are evil.  Why?  Because some of these objects you can't analyze statically.  You have to see them on the heap at run time.  So, in this case, the Twitter application that we're going to look at has the PID that have.  And that Twitter application has been back doored with an interpreter malware.  It's behaving like malware.  And you can see, I'm not a UX designer of sorts.  But we've managed to hook into the process of malware and identify that as making use of a class loader, that's running and instantiated some TCP objects.  This can go into your UR overlay attacks and a whole bunch of other stuff which is really cool.  And the static analysis, you would miss this functionality unless you got hold of the decks code that was invoked by the class loader.  You don't get it with the APK.  It's invoked and downloaded and then invoked.  So, that's a lot of fun.
      And this machine  what are the future plans?  Well, at the moment this works really well on ART and on Dalvik, but we are relying on Freida, which is cool.  It's quite cumbersome.  This works well for the virtual machine.  It's really easy.  But ART is a different story.  It uses jemalloc, if you know that, you're my new best friend.  We have moved Freida.  We have done this, merged into the AO SP with the custom bulbs and used it as a run time antivirus scanner.  This app is acting dodgy.  Tell me.  It will say, yes.  It is acting quite dodgy.  And that is me.  Was it under ten minutes?
      >> Yes.  It was under ten minutes.
      >> First time that's ever happened.
      >> Need more hands for this.  Is the coder Dojo person here?  Nope.  And previewing with a touch of science and a dash of engineering?  Okay.
      >> Thank you.  Good morning, everybody.  I'm Chris.  And I like cooking and I also like making things.  This is a short talk about something I made a few years ago, Raspberry Picontrolled sous vide.  It's a cooking technique, and it literally in French means under vacuum.  And the vacuum part is probably the least important thing about the technique.  So, the idea is you put food into a vacuumpacked plastic bag.  And the plastic bag is there to stop it from getting wet.  Because you then put the vacuumpacked plastic bag into a water bath and the water bath is at a precise temperature in order to cook the food as you want it to be done.
      So, you don't actually need a fancy vacuumsealing equipment like you see on the lefthand side which professional chefs might use for this technique.  You can actually get away with just a Ziploc bag and sucking the air out with your mouth or something.  The only reason you need to get the air out is to stop the bag from floating in your water bath.  And you might also, if you're doing kind of long cooking, worry a little bit about oxidation if you left a bunch of air in the bag along with the food.
      So, the purpose of the sous vide technique is to have precise temperature control.  And especially when we're dealing with proteins, it's about making sure that we denature just the right protein.  So, most cooking is actually technically when you get down to it all about either breaking down long chain molecules or persuading short chain molecules to join together into long chain molecules in order to have an outcome.  And we look at the six different examples of eggs here on the screen, then each of those is only a few degrees centigrade apart.  So, going all the way from running white and runny yolk through to essentially a hard-boiled egg is a handful of degrees for each step.  And so, you can go from sort of everything runny to just the yolk runny to things starting to firm up a little bit and eventual all the way to a hard-boiled egg.
      sous vid is one of the techniques that's covered in this excellent book I kind of pulled up here, cooking for geeks, which is an O'Reilly book.  All O'Reilly books are great, but this is one of my favorites.  It's not a typical O'Reilly book in being about a programming language or a framework.  It's kind of there to say how science works in preparing food.  And so, as you go through the book, it's got lots and lots of different techniques in there that I used for denaturing proteins, mostly.  And sous vide is in there as just one of them.
      So, to do accurate temperature control in a water bath in order to do this cooking, we need some kind of control system.  Our input is going to be temperature.  We need to be able to measure the temperature and measure that temperature reasonably accurately.  And our output is going to be a heating element.  And in the middle, we need some sort of control system.  So, we measured the temperature and we turned the heating element on and off in order to get that temperature about the water medium to be exactly where we want it to be.  The thing I put together about five years uses a DSEV20 temperature sensor.  And specifically, it's a one that's immersible.  You can see in the left-hand picture here, most of the picture is the Raspberry Pi with a little daughter board on top of it for the bits and bobs I put together.  And just on the right of the Raspberry Pi is the immersible temperature sensor.
      These things cost about a quid on eBay.  And interfacing using a product called Onewayer.  And a little bit of what see on the Raspberry Pi is the resister and the three wires running from the sensor.  So, it's got 5 volts, ground and a single data line that's pulled up with a little resistor.  So, that gives accurateish temperature.  And those things output to about a resolution of about an eighth of a degree.  That gives the temperature starting point in terms of the input for the control system.
      The righthand side shows where I did the water bath.  And this was an old slow cooker.  You can see the little bit of sucre holding the control system at the front together.  Slow cookers do everything that we need here in that they've got a heating element and they can contain water.  What they don't do is anything like accurate temperature control.  And so, it's got three settings on it there.  It's got high, low and warm.  And basically, all of those will boil the water inside of the slow cooker at some kind of ferocity.  It you want to cook on warm, it don't do it.  The middle is the control system.  Implemented on a Raspberry Pi and it's running a bit of Python code to implement a control system, P ID, proportional, integrating and differentiating.
      So, the output is taking the temperature and deciding how much it wants to turn on the heating element according to a proportional relationship with the temperature difference between where it is and where you want to be.  An integral of that  so, if you've got a big gap between where you are and where you want to be, you want to put more temperature into the slow cooker.  But you also have a differentiation term in there.  Because as you approach where you want to be, you actually want to ramp down so that you don't overshoot the temperature that you want to be at.
      That's all just implemented in a bit of Python code.  And what's actually going on here in terms of output of that is 433-megahertz remote control socket.  So, Maplin used to sell these things when Maplin was still alive.  And somebody had already created a Raspberry Pi library for that, Raspberry Pi strong on and off.  Which took care of turning the remote controllers on and off.  And the reason I did this was interfacing a Raspberry Pi directly to mains electricity to turn this slow cooker on and off is kind of dangerous when you're messing around with things that are wet and things that are hot.
      And so, I wanted something that was inherently safe in the kitchen environment.  And so, those off the shelf remote control main sockets are pretty good.  And it provides a huge degree of isolation between the Raspberry Pi itself and all of the hot, wet stuff.
      Anybody that's ever done anything with serious realworld control systems will know that control systems can be tricky.  And so, the top chart here is an example of an early run with this thing.  So, I was trying to get the water bath at about 56 degrees, the cooker, a steak at about medium rare.  And you can see that it wound up there and shot across 60 degrees
      Reaching about 62 degrees.  So, that's the state we're in already.  And then a few minutes along, you can see that there was some kind of error in the control loop.  And it went away to over 70 degrees.  So, that was the steak properly ruined at that point.  And once that error was noted, I kind of manually switched it off and the temperature slipped back down again.
      The lower chart is a better example of what we're trying to achieve here.  And so, in that example I was aiming for 60 degrees.  You can see that it ramped up quite rapidly to almost 60 degrees.  Then just bumbled along with a little bit of oscillation.  It's almost impossible to get all of the oscillation out of a control system, but you can tune it to get that minimized.
      The remarkable thing in the world of machine learning and artificial intelligence is that these things still aren't autotuning.  So, we can try and fight Spam, but we still can't control the temperature of a crock pot.  Reverse engineering can also be tricky.  So, my map in remote sockets, two of them died, so, I had to reverse engineer another one a few years ago since you can't buy them anymore.  This is the output from the diagnostic software from remote control commands and I've had to use a platform called PiLite to reverse engineer it on and off.  But perfect brisket at the end of the day makes it all worthwhile.  And not shown here, the amazing gravy you get from all the juices in the bag when you're cooking with this technique.  Thanks for your time, folks, and I'll be around if people have questions.
      >> Okay.  Up next we have the CoderDojo talk.
      >> Hi, everyone, I'm Richard Taylor.  I work for the foundation.  I'm here to talk about CoderDojo.  Anyone heard of CoderDojo?  Oh, great.  Fantastic.  Who has been to a CoderDojo?  Who is a mentor or a volunteer at the CoderDojo?  Good.  Maybe after the end of it I can persuade you to do that.
      So, for those who don't know, what is CoderDojo?  The key thing about CoderDojo is it's free programming clubs for young people aged 7 and 17.  Run in local communities.  The idea is like all the coding clubs that you hear about like Code Clubs are pretty jam, those places, it's a place for young people to go and learn about being creative with technology.  CoderDojo was founded in Ireland in 2011.  The first was in Cork in Ireland.  And since then, more than 2,000 in a hundred countries.  We reckon about 58,000 people around the world benefit from CoderDojo, coming to a regular club where they can learn more about CoderDojo and coding.  One thing on the side is the word ninjas.  In CoderDojo, we have adopted the Japanese martial arts.  The young people who participate in CoderDojos, they're called ninjas.  It's an open source model.  The whole thing about CoderDojo, you take the idea, which is free coding clubs for young people and turn it into what you want.
      So, one thing we really encourage, for example, is for people to hack our logo on their badges.  You can see a few of them here.  And the open source model means if you're interested in anything to do with technology and coding and you fancy helping young people learn about it, you can take CoderDojo, start a CoderDojo and teach those young people what you think they should know.  What are the benefits?  First is the obvious one.  You're learning to code.
      The national curriculum in the UK, revised in 2015 is a lot better now in terms of actually teaching people programming skills rather than just the oldfashioned ICT.  Everything revolved around PowerPoint.  But still, we hear from young people all the time that they don't get enough real programming lessons in the schools they have.  My son's a prime example of that.  Every computer lesson, he moans that he didn't really do anything.  Isn't that right?  Good.  Thank you.  Good audience participation from your own family.  It's a social event.  CoderDojo  some people think it's a darkened room with lots of pasty kids not talking to each other.  It's not that at all.  They're vibrant, a lot of buzz in the air, and lots of mingling and people getting together and talking about things.  I took my neighbor's son to CoderDojo a couple years ago.  His parents are great.  They're supercreative, really musical and arty, but not really geeks.  Not really into coding and that kind of thing.  He loved it.  And the comment to me was it was really great to spend time with some likeminded people.  That's the social thing that CoderDojo offers young people.  Also, an opportunity to be really creative and to build things.  Most CoderDojos will start off with a pre-configured activities.  Learning basics, lighting up an LED with an Arduino or hacking on a Raspberry Pi.  But then it's openended and young people are encouraged to build and make projects that satisfy their own desires.  And we have the coolest projects, an opportunity for the young people to share what they built.  So, internationally, it happens every year.  It happens three or four years, bigger every year.  And you can see on the picture here, it's in the RDS in Dublin.  And young people from CoderDojos come to show off the things they've built over the last year.  There are lots of product categories.  There's a bit of a competitive element to it.  I was lucky enough this year to be a judge as you can see from my Tshirt.  That's an amazing opportunity.  I got to see lots of great projects that young people have done.
      It is a huge thing, right?  I had never been to Dublin before this year.  This is a picture I took from the front stage.  The scale of it is amazing.  600 projects, 950 young people, all into coding, all into being creative, coming together to show off what they've made.  I have judging the evolution category.  It's a random thing, it's not an obvious category and it's a bit advanced.  That was great to see the people doing things there.  This is the winner, Andre, all the way from Bucharest with his mentor.  He built this cycling thing.  I don't know if this movie is going to work.
      This is just a movie of what he built I took on my phone.  Basically, it was a cycling belt.  So, he put some neopixel LEDs into his belt.  He had an Arduino and a custom PCB that he made and written an app for his phone to control this belt as he cycled along.  So, he could do things like pretend to have a police car with nice flashing red and blue lights.  He could do indicators, obviously slightly more useful to tell people where he was going.  And doesn't show it on this movie, but if he had a bad experience where a driver cut him off, he could have a nice, friendly message to the driver.  Perhaps not to come so close in the future.  And the slides.
      And I can't use the mouse lefthanded.  So, I was just kind of blown away by Andre.  First thing is, he's 9 years old.  He's had loads of help from the mentors.  And some people criticize CoderDojo.  He didn't do it by himself, a mentor helped him.  He knows this is possible and something he can do in the future.  Maybe by himself.  That's what CoderDojo for me is all about.  It's about giving the young people the knowledge and the confidence.  The way to build things for themselves and to see beyond their sealed up iPad that they can't really open because it's glued together.  The important thing about CoderDojo, just like EMF, it's all powered by volunteers.
      The people who run the sessions with the young people, the people who arrange the logistics, do the ticketing, they're all volunteers.  We have hugely impressive volunteer community in CoderDojo who help share resources, share tips and ideas and, of course, get together for social events around projects.  But really my main call to action at the end of the talk is to encourage you guys here, if you fancy helping young people learn to be creative with technology, think about whether or not you could help out with the CoderDojo.  There are loads in the UK and Europe.  If there isn't one near you, start one up.  The process is simple.  I'm going to be a champion at CoderDojo.  Find some other people to help you, find a venue and the UK libraries are a really good venue for CoderDojos.  We have been talking to library groups around the country.  Keen to get more people coming into the Dojos.  Find the first and do it.  And you can do ticketing and all the promotions to help attract young people to come to the Dojos.  And to be honest, no CoderDojo in the UK is undersubscribed.  They're all oversubscribed because the demand for this kind of thing is really high.  That's all I have to say.
      You can find out more at the CoderDojo.org website.  To be a volunteer, CoderDojo.org/volunteer/UK.  I'm happy to talk to people who have questions about CoderDojo.  Follow me on Twitter or follow CoderDojo on Twitter or look at our Facebook page.  Thank you very much for listening.
      [ Applause ]
      >> Okay.  Next up we have the augmented reality.  And just a quick request from the volunteers, especially with lunch, if you're free now, we would love some assistance.
      >> Hi, everyone.  I'm Ian.  I'm recently started as a computer vision engineer at a company in Bristol.  And I just thought what we do is really kind of cool.  So, I thought people might be interested in I came and talked about it.  But before I talk, I'm going to hopefully talk for itself.
      ¶ ¶
      >> So, that guy was MekaMon, there's a little one at the front here.  He's our kind of main toy product at the moment.  So, we're fairly new startup, four years.  I've been on the team five weeks.  Don't ask too many indepth questions, I can't answer them.  But it's quite a progressive company and a kind of company where we want to get people inspired.  We're enthusiastic and love robots and hopefully that's what I'll get across today.  The fourlegged robot.  Each leg has a degree of freedom.  So, he's fairly nimble.  He can do little flips and right himself, hopefully.  Although he's not managed it on the grass so well.  And one of the things to do with this is not just have a robot you drive around, we want to have people be able to play games with each other.  So, we're working on  if you have two of these, you can battle them together.  Or if you have one, we're currently working on an augmented reality gaming app.  That's what I'm here to talk about because that's what I do.
      So, this is a fairly old demo of our original augmented reality game.  So, you can see you have it there.  And he's fighting a virtual opponent.  Basically, it's just a case of defending your base.  We have  everyone has to have the Metroids game at some point.  So, this gives you an idea what we're looking for.  We want to control it with the phone, put it in your living room and play with it.
      >> Gaming and augmented reality.
      >> So, that's cool.  That works really well and that's already there.  So, why do I have a job?  So, there's something on this image and something on that video that is the reason I have a job.  I don't know if anyone could spot what might be causing us problems with this current way that we're doing it.  Any ideas?  Shout at me.  What about if I do this?  Does that give any more clues?  So, what we have  the only way we can track the world with the original app is to have this special mat in view at all times.  And that mat is only about 1-meter square which means that we're really limited on where we can drive the robot, what we can do, how we can interact with your space.
      So, moving that into something where we don't need the mat is where I come in.  And the other problem is, and it's a physical problem.  We have a robot with grippy legs, so he doesn't fall over and the map that he has to interact with.  There's a clear problem, when the robot runs on the map, and moves the map and essentially the entire game world moves.
      So, what we're working on, apart from you guys, only a few have seen this.  It's using technology on the new Android phones and iPhones that allow us to build up a model of the world and embed our stuff in.  We have a virtual, our guy's the silver one.  I have a working demo on my phone.  If you want to play it later, bug me.  And my boss brought a couple.  We can move around the living room, fight and play the game and embed the scenery.  It's kind of cool and it's kind of working.  There's still a lot of challenges.
      So, my background is computer vision.  And the biggest challenge with this is we now know where your living room is, that's great.  But we need to know where our are robot is.  And we can kind of see things like they're moving around.  But if we want the cool effects like on the earlier video, I need to know where the head is, where the legs are and how I'm moving.  I need to make sure I'm not putting my robot into some scenery we've created and know that little robot is not going to walk straight through a plant pot because it ruins the illusion.  We have techniques like a nice, shiny blue head.  That's a new feature.  And then a blue carpet.  What do I do?  I'm playing with deep learning and neural networks to model what the robot look like.  It's early days.  We're launching this in about a month.  It's early days, but I'm not going to sleep very much for the next month.
      So, the other thing I wanted to talk about, as I say, the thing that attracted me to Reach is we're trying to encourage more people into robots.  Make it exciting.  Robots are inherently exciting, but we want people to play with them in a more interactive way.  We're working with schools and universities and trying to run internships to bring people into the fold and encourage them to do stuff with the robot.  And to that end, we're working on a visual programming language for people to use.  Scratch the interface and make the robot play around.
      The other things we have got which have slipped my mind.  Oh, yeah, of course.  We're putting together a robo cup 2019, hopefully we'll be involved with that.  I think that probably covers most of it.  I think I have also raced through in seven minutes instead of ten.  Thanks very much.  I've got two of these guys with me to play around with.  So, yeah, come find me.
      [ Applause ]
      >> Okay.  And now for the final lightning talk of this session is artificial intelligence in brain fuck.
      >> Hello, I'm Tim, I have a website, and I'm going to talk about artificial intelligence and brain fuck.  Just a quick overview, I imagine most people are familiar with it, but it's a simple programming language.  Designed not to be practical, but to be fun.  It's very, very simple.  It's only got eight possible instructions.  Eight characters that are valid.  I mean, it's a little bit like programming an assembly language.  But even in assembly you have arguments and addresses and, you know, the up codes  they're quite large.  You know, 16bit or more.  And so, in a way you've got 65,000 possible instructions if you've got 16bit op code.  In brain fuck, it's literally eight instructions that you could use.  So, you can fit on to a paper tape 3 bits wide.  So, the instructions are, we have one big address space and one pointed to the address space.
      And the first instruction, the plus, is increment the cell that the pointer is pointing to.  And the second instruction is decrement the cell that the pointer is pointing to, and next two, move the pointer to the left and the right.  The dot and the comma are your input and output.  So, that's it dot is print the value of the current cell.  It's 1 byte.  So, it printed a standard output to the terminal or whatever.  And the comma is take one byte from the standard input buffer and write it to the current cell.  If there's nothing in the buffer, it's normally blocking, waiting for input.  The brackets are controlled logic.  Basically, all of the logic are within these brackets which the open bracket says if the current cell is zero, jump ahead to the corresponding closing bracket.  And if the  the closing bracket says, if the current cell is not zero, jump back to the opening bracket that corresponds to it.  So, the code in the brackets runs until the cell pointed to at the ending bracket is zero.  And, of course, could be nested.
      So that's the language, basically.  And I wanted to write something in this.  Very few people write anything in brain fuck because it's ridiculous.  But I wanted to write a useful program.  There's a lot of programs which like these walls of text that I think were compiled to brain fuck.  Which is still an impressive achievement, but not the same thing as writing an entire program in it.
      I said it's artificial intelligence, it's not machine learning.  What I wanted to write was a computer component to a game.  And the game I chose was Tic Tac Toe or knots and crosses.  But this is surprisingly difficult.  The very first thing I do was try to make a user interface.
      So, the  program is going to print to the terminal.  A little ASCII diagram of the board.  And we need to take input from the human and then place an X in the little ASCII diagram.  Make our own move, place a naught and then draw the board again.  So, just the very first bit then.  Let's start with choosing a number.
      So, if you  just type a number between one and nine and put an X there.  That should be fairly simple, right?  But even that, you have to take that byte of input and say, was this between ASCII zero and ASCII nine?  I don't have time to explain this program.  It's not clear.  This is what most brain fuck programs look like.  All the text that's readable is comments.  Everything else is ignored.  This does technically work, but it's completely ill eligible.  The bit in the middle is doing a loop.  And you have to destroy the value you're looking at.  You have to copy the value to somewhere else.  Even copying the value to somewhere else is difficult.
      So, this technically works.  So, we can  in this particular case you can consider this like a module.  We know how much memory it uses.  We know where the pointer is at the end of it.  And in that case, we can just kind of like clump it together and drop it into a larger program.  To write this, I fiddled around with if in the interpreter.  Which for something any more complex I'm just saying is this greater than or less than a number isn't scalable.
      So, the actual program  well, okay.  So, we need to decide how we're going to store this board in memory.  And you might think, okay, you have three possible states per grid location.  It could be empty, an X or a naught.  Let's have zero, one, two in nine memory cells.  But as I just explained, doing comparisons is really hard so it becomes very tedious.  I did try to write program like that and it didn't go well.  I tried to write it, but I started over.  And I said assign bits of flags.  It can only be a one or a zero and we can use the brackets to do simple comparisons if we know it's going to be a one or a zero.  The code becomes a lot less verbose.
      So, we've got a number that the user has typed.  We've confirmed it's between a range.  Now we want to go to the place in memory.  We have three cells per grid location.  This is a flag for yes, it's empty, or a flag for, no, it's got an X or no, it's not a naught.  And now do an indirect jump.  This is  I think this is a rather elegant bit of code.  Keep decrementing the cell and keep opening the bracket until it reaches zero, of course.  And then move three spaces across for every one of the numbers we've decremented by.  We're where in the array.  This is occupied.  Go back to the choose a number routine or mark it as an X.
      But now we're lost.  We've done an indirect jump.  We need to know how to get back to our home position.  So, well, I suppose you could do a link list or something.  It's going to get very complicated.  What I came up with was putting markers in memory.  So, if you consider something like this, what we're doing is we're checking that some code will run if the value of the cell is one.  We decrement and then do is it zero?  If the value is not one in some code.  The point is, by putting the plus immediately after the bracket and the same on the closing bracket, minus then plus, we leave the cell unchanged.  So, we can run this on any cell.  And whether or not that runs, it will have the same it had at the beginning.  So, we can do something like this.  This is a little bit like a glider in the Game of Life demonstrations.
      What this code says is, keep going left until you hit a minus 1 value.  Because I've swapped the pluses and minuses around.  So, I chose minus one as like this special value that will only go in certain places in memory.  So, after we've done our indirect jump across, we can run back to the minus 1 value and know that we're a known location.  So, I use this quite a lot in the program.  I'll just give an example of one of the bits that we're doing.
      So, this is a test to say, has X1.  This is one of the tests to see if X is 1.  This is we move to the start of our array.  We then move across by one to say we're at the X flag.  Then is the first cell an and X?  Is the second an X?  The third grid location an X?  If it is, then run back to the reference point and move a position to the particular flag that we've assigned as X is 1 and set it and run back to where we were before because we have a whole load of other comparisons as well because we don't want it to break.  It is repeated, all the horizontals and the verticals and the diagonals to say X is 1.  Here's another example of that.  Is it a draw?
      So, we can say first when we set a flag to say, yes, the board is full.  We go through every single cell and say, is empty.  Okay.  So, there's a certain elegance to that but I'll skip ahead to the demo which is  I know I haven't really actually talked about the logic of the thing.  But this is my finished code.  It's all on GitHub and talk to me afterwards if you want to learn more about it.  But here's an interactive demo.  I have my little ASCII board there.  I press 5 and put the X in the middle.  And the program decides to put a thing over there.  Press 2, and it blocks me.  And then, I don't know, 7.  Eight  nine.  And then  anyway, feel free to play with that.
      I'd like to talk more about the logic of the program, but I don't think I have time in this talk.  So, yeah.  That's it.  Thank you.
      [ Applause ]
      >> Okay.  Thank you.  And just once again, can we thank all of the speakers today?
      [ Applause ]
      And just a quick announcement.  We need volunteers for all sorts of jobs.  And if you have some time in the day, we can take advantage of it.  You'll help make the camp better.  Please report to the volunteers tent and we'll put you to doing something fun.  Thanks. 

