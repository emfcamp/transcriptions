      Cracking HiTag2 Crypto
      
      Kev Sheldrake
      
      KEV: So, it's been quite an exciting day.  I spoke  hi.  I spoke at about half past 1:00 in the other tent which I was very, very sober.  And all I could say is I have been sitting in the sun drinking ever since.  I am going through this quickly.  And I'm only going to be able to talk about some of the content that's normally in this talk because of the limited opportunities to  the limited length that we have to speak at.  But if you do have any interest or you want to ask questions or you want to just come and hang out, I will be outside the bar, buy me a beer.  Ask anything you like.  And I will demonstrate every crack that I don't have in this talk then.  But you have to buy me a beer to get to that point.  This is me, I work in cyber.
      I do interesting things with crypto and HiTag ID.  Why do we copy RFID tags at 120 kilohertz?  For those who don't know, low frequency is 125 kilohertz, and high frequency is megahertz, and very high frequency is 866 megahertz or 433 megahertz depend on where you live.  Why do we care about it?  It is quite old as a technology and they're out and disappearing.  It's because they're used to protect things that are far more valuable than the amount of money it costs to break it.
      And most 125 kilohertz RFID tags are rubbish.  But the ones I'm talking about are less rubbish, but still rubbish, unfortunately.  They're also used to implement the car mobilizer in most cars.  I've since been contacted with these talks by Audi and Nissan because they're using that technology.  Who knows.  So, no normal RFID looks like this, it transmits a single page data over and over again whenever it's piled up.  And there's a synchronization pattern.  And it reads whatever bit comes afterwards and turns that into a number and that is the number they then use to make access control decisions.  Clearly you can copy these easily by just the field at 105K and seeing what number comes out.  Write it down, and then the tag.  So, they're truly able to break.  And in electromagnetic sort of spectrum basis, this is kind of how it looks.  The reader emanates the field.   The tag has no battery.  It absorbs its power from the field and damps that field on and off in a pattern to signal information to the reader.  And if the reader wants to transmit information to the tag such as I want you to write this page at a particular value, then it damps the field in a particular way as well.
      The way that they damp the field is one of these types of keying modulations and possibly encoded with Manchester by phrase or not as the case may be.  I'm not going to talk about this anymore.  The many months I spent looking at this technology, I learned a lot of this stuff is none of this is interesting to the crypto world.  Yes, it's interesting if you care about radio.  And I did at the start of this project.  So, I'm quite happy to talk about it.  But honestly, the crypto is much more interesting.  We'll skip this built.  To secure 125 kilohertz RFID, we want authentication and encryption such that you couldn't replay the comms and couldn't copy the tags easily.  That's kind of the goal.  So, I'm going to talk about HiTag2, which is one of these.  Not that it makes any difference.  That's a standardize card.  It's the technology probably in your car immobilizer and possibly in the tags that let you into the building that you work in.
      In password mode and in cryptomode.  You might know it from the contents.  I'll talk about password mode for a small amount of time and talk about crypto mode a large amount of time.  Password mode is rubbish, as we're about to see.  What I won't be talking about is everything else and specifically cars.  Come and talk to me later if you want to know more.
      So, it all started with an academic paper.  Basically we had a job which involved breaking into buildings by copying RFID tags.  And one of my colleagues said, I think this academic paper says a lot about this sort of system we're looking at breaking.  Would you like to have a look at it and implement the stuff we're talking about?  And this is the academic paper.  It's called gone in 360 seconds:  Hijacking, by Barb, I've met Garcia, he's a lovely man.  Very Italian.  And the stuff they did is awesome.  It's very, very clever in mathematics.  It's very hard to understand.  They wrote code to implement three attacks in this paper when they produced the paper in 2012.  And then never released their code.
      And for five years no one had written that code and people were asking for it on the RFID forums.  And that's why we decided we should write the code and release it, which is what we have done.  So, HiTag2, what does it look like?  It kind of look like this if you drop it into acetone and magnify it with a child's microscope.  So, for the sake of a pound for the acetone, and 700 pounds for the SLR you can get this.  And it does say HC2, which means HiTag2.  And if you looked closer, it says Micron, and Philips bought and XP was rebranded to.  But this is largely pointless.  It's just fun.
      But a HiTag2 looks like this.  This is logically what it looks like.  There's eight pages of 32 bits of data.   The first page is the UID.  That is stamped in the factory and is not changeable.  You can buy Chinese HiTag2 tags where you can change the page zero data.  But typically the vast majority in the world that you'll see you can't and it doesn't matter, because it's not important to the crypto.
      Pages 123 contain secrets, which is why they're red.  Pages 47 contain user data such as this user's IED within the system which the system then makes access control decisions over.
      So, whether you're in password or crypto mode, the whole system resides on shared secrets.  Now, it would be lovely if there was enough processing power to do asymmetric crypto, but there's not.  125 kilohertz isn't the power to do these.  You have to do symmetric encryption.  And with that, you basically have to share the secrets.  What that really means in practice is that if you have a system with a thousand doors and 10,000 users with tags that can open those doors, or a subset of those doors, then every door reader and every tag has the same secret within it.  And you only have to compromise one bit of that system to access the secret and then you can compromise the rest of the system really, really quickly.
      So, this is kind of fundamentally bad as security goes in terms of access control.  When you move into the worlds of megs, and look at EV2s and things like that, these problems don't really exist in this kind of form.  And things are much, much better.  But if you were to look at another cryptosystem, whatever it happens to be, and you found that kind of signature, then alarm bells should ring.  You should think, I could compromise a tiny bit of this and own the whole thing.  And to compromise a tiny bit of it really means I just need to steal something and take it apart.  Which is kind what have I did.
      So, password mode.  I'll talk about password mode really quickly.  The reader in password mode constantly emanates the pattern 1000 using modulation of the field.  And I'm going to tag into the field and are powers up, it sees that and responds with the UID value on page zero.  The reader then sends page one in clear, which is the system password.  And the tag responds with the tag password, page three, in clear.  And then the reader talks to it in clear and the tag responds in clear.  So, if you can eavesdrop on that, you can get the passwords.  Password mode is awful.  We're not going to talk about that.  crypto mode, however, starts with the same thing.  The system can be in either password or crypto mode, it's not a hybrid.  It's the same pattern as the modulation.  And the tag responds with the UID in clear because there's no established cred at that point.  But at that point, things are seeded, the encryption exists and the reader sends the encrypted value to the tag.  The tag responds with an encrypted page three.  The reader can then send encrypted commands and can then respond to the encrypted responses.  So, the whole thing is much more encrypted.  This is kind of how it looks in terms of what data is need where.
      The reader has the key and the nonce, receives the UID from the tag and sees it and randomizes the PRNG.  The tag has the same tag, it uses that to seed and have the same PRNG.  And both end up in exactly the same state.  This is a key thing that I keep forgetting to say when I give this talk.  If the PRNGs are exactly the same position, seeded and randomized with the same data, they will then check out the same randomized binary stream.  That's important.  That's how you use them in a stream.  For example, if the reader wanted to encrypt data to send to the tag, it will encrypt 32 bits of data.  I'll get 32 bits of randomness from my PRNG, and X all that with my data and send it to the tag.  And the tag could go to its PRNG and go, I want 32 bits of data and it would get the same 32 bits that the reader got because they're in the same state.  It can then X all of that with the data received and that will give it back the plain text.  This is a key thing to how this attack  or the first attack that I'm going to talk about works.
      So, stream side is, if you aren't aware, they're  stream surface ready restructure beneficiary, they're awful, please don't use them.  Don't take any of this as examples of ways you should build systems.  But the amateur cryptographer next to you will tell you the only secure cipher in the world is a onetime pad.  And it's not.  Because it has no integrity protection.  I can own the onetime pad with certain caveats.
      Anyway.  Let's talk about the HiTag2, PRNG and encryption.  The HiTag2 is based on a shift register that is 48 bits wide and initially seeded with the 32 bit which the from page zero of the tag and the first 16 bits of the key.  Which the tag and the reader both know.  Next up, the reader invents a nonce.  That 32bit value, which could be properly random.  It should be properly random.  And has the 32 bits up of the key and pushes that one bit at a time into the LFSR as it extracts bits from the LFSR.  Those bits it uses to encrypt the nonce with each bit from the LFSR, creating an encrypted nonce sending to the tag.  The tag can then do the same thing., so it gets the output from the PRNG, has that with the 32 bits of the key and the encrypted nonce.  You can't do that from the outset.  You don't have 32 bits at the beginning.  You have one bit.  You only have one state that you know.  You take the first bit of the output from the LFSR, PRNG, and the first bit of the upper half of the key and work with the encrypted nonce.  Which will decrypt that bit of the nonce with the key.  Which is the next value that you need to push into the LFSR.  This then pushes that value in, shifting the LFSR and then you can generate the next bit of the output.  And then the next bit of the key, X all that with the next bit of the nonce to decrypt it, the key, which happens to be the value that you then push in.  It's a really neat scheme, and when you've done it all, the reader and the tag end up in the same state.  It's not secure.  But I really like it.  It's kind of cool.  All right?  For it's like how to decrypt and seed your LFSR at the same time.  It's a neat thing.  It's just not secure.  All right?  For really complicated mathematical reasons that I don't go into in this talk.  But it's not secure.
      I will say, if you're interested, by the time I get to the end of this, I'll be pointing you at GitHub where you can find all the other code.  Other attacks that I've implemented from the academic papers.  None of this is my invention.  I've literally just coded up what they said in maths and turned it into it.  But other attacks use that fact to completely break the crypto really, really quickly.  So, it is worth bearing in mind.
      Anyway, so, after the tag and the reader have gotten to that state, they have no more randomization or seeding information.  They need to continually be able to shift through the LFSR and invent new bits that get pushed in as the thing shifts.  They use the feedback function, L, to generate the new bit.  It takes the LFSR state and generates one bit.  And so, when you encrypt, it kind of looks like this, literally you get output from the PRNG, and with the data and produces encrypted data.  It's a scream cipher.  And the receiver can do exactly the same thing.  The function L will produce the same bits based on the state you started with, it gets the same PRNG output and with the encrypted data and return back to the plain text and then you have the plain text data.
      The feedback function if you care looks like this.  It's literally the X of the 16 bits of the LFSR.  The LFSR is 48 bits wide.  It takes 16 of those, put together and that's the new bit of output.  That's the new bit shifted in.  If you don't know the entire LFSR state, there's a good chance you don't know the new bit getting pushed in.
      And the output of the LFSR, the PRNG, is not just the bit that falls off the righthand side when you push it through, it's actually generated with a filter function.  And that filter function is based on functions A, B and C in this current arrangement.  Functions A and B take 4 bits each from the LFSR and produce 1 bit of output.  And there's five single bits of output pushed into a function C and that's one bit of output.  That is the output.  Each of functions AB and C are biased 5050.  If you don't know the input job you can't predict the output.  There's a 50% chance a 1 or a zero.  It looks pretty secure.  How could you guess this sort of stuff?  You look at some of the other attacks, those academics are quite clever.  There's ways of breaking these things that I've implemented and you can read the C to see how to works.
      Going back to the slide about how crypto mode worked, it sends the start off.  The tag responds with the UID, it resends the encrypted value, the tag responds with the encrypted password and then the reader sends encrypted commands and the type responds with encrypted responses.  So, let's look at HiTag2 commands.
      HiTag2 command is only 5 bits long.  The first two determine which command it is, read, read page, write page or halt.  And the following three bits determine which page of data we care about.  If we're trying to read a page or write a page.  Those three bits will tell you which page we care about.  Read page inverted is read, but it's inverted.  And halt turns the tag off until it leaves the RF field and comes back again.  A use case of where that's used is in Las Vegas casinos, every chip has a tag inside it.  And the entire table is circulated by an RFID field.  They can track every tag being on the table or not on the table.
      So, when you set your field up and you kind of go start auth, the first or fastest or loudest tag will respond.  And that will be the one that the field hears.  And then the field will then communicate with that one.  All the other tags will ignore the communications because they don't meet the integrity checks that I'll come to.  And then it sends the halt command that shuts it down in the field.  And then start auth and then the next loudest or closest or noisiest tag will respond.  And it will talk to that one.  And circle through all the tags in the field.  You can talk to multiple tags within a single field using this because you can halt the loudest ones first.  If you see what I mean.
      So, if you want to use this in a really hostile environment, take it to Las Vegas.  Apparently they use this stuff.  Now, so, HiTag2 commands are 5 bits long.  But in actual fact, a practical level, when you send them, they're 10 bits long.  It's the first 5 bits followed by that 5 bits inverted.  So, zero goes to a one, one goes to a zero.  One, zero, one, one, one, inverted becomes one zero  the minimum size it can be is 10 bits.  This provides integrity checking.  If you're trying to read a tag or maybe you're trying to write a page and the write page command gets corrupted and you accidently write to the wrong page, that could be quite devastating in some kind of industrial situation.
      So, with this, the same bit would have to be corrupted in the first five bits and the second five bits for it to pass the integrity check.  If basically checks that each block needs to be the inverse of the proceeding block.  But extendedwise, you can have as many of these blocks as you like, as long as every block is the inverse of the preceding block.  You can have 20 blocks as long as it goes normal/inverse, normal/inverse.  Which apparently adds to the integrity.  What it actually does is creates a hole through which we can attack the system.
      Let's talk about attacks.  We're going talk only about the first attack.  But the academic paper from 2012 has three attacks in it.  I've implemented all three.  I'm going talk about the first one.  The Flavia Garcia wrote another paper in 2016 which has a new attack which is much faster.  Vincent Immler produced a GPUbased attack that took 11 hours brute force in 2012 and last year the French government produced an optimized government that would work on Amazon using multiple GPUs and multiple hosts.  And I got word only last week that one of the other authors of the first paper produced a new paper last year that can attack the whole thing in like 30 seconds  like 30 seconds or something.  Some incredible another attack that I now need to read about just for completeness to satisfy my OCD.  There's lots of ways of attacking these things.  I'm going to talk about one.  The nonce replay and length extension for key stream recovery attack.  It's a long sentence, but straightforward.  We're going to replay a nonce several times.  And using that, we're going to extend the amount of key stream that we can recover until we get enough key stream that we can then break the crypto.  What you might have noticed when we were looking at how these things worked was that all the entropy comes from the reader in the form of the nonce.
      Sob with if you have one tag, one HiTag2 tag, you'll get the same UID.  If you stick with one tag, that UID is not going to change.  The key on it equally is not going to change because it's the same key on the entire system.  And that is, again, fixed.
      So, nothing on the tag is generating any entropy.  When you put it in the field of the reader, the reader takes that and seeds it and generates and encrypts the nonce and sends it to the tag.  And the nonce together with the UID is what seeds the PRNG.  So, so the only entropy is that nonce.  So, if we have a device such as one of these perhaps.  An RFIDler, and we eavesdrop on the communications between the tag and the reader, we can steal the encrypted nonce from that one handshake.  And then in our little back smoky room somewhere else, we could then replay that nonce and challenge the value over and over again to the tag.  And every time we replay it, the tag resets to the exact same position each time.  The same PRNG position.  Because all the entropy comes from that nonce.  And the response value just proves that the nonce is a valid nonce, essentially.  Properly encrypted.  So, if you remember that this is the position that the reader and the tag got into after they received the randomize.
      Then we can create this in emulated reader.  And pretend to be a real reader.  Because all the reader has to provide is the start auth command, which we know from this spec.  The encrypted nonce we captured.  The encrypted response value, we captured.  And then gets back the encrypted page feed from the tag.  In which point the tag is in a particular state.  If we do it again, it's in the exactly the same state.  No matter how many thousand times we do this, it's in the same state every time.  For the encrypted nonce of 4 ARP2F, we might expect the one, zero  for example.  And each time we initialize the tag, we get the PRNG output, that's being used to encrypt the stream of data.  It's kind of really important to understand how the nonce replay works.  Which is why I labor that point so strongly.  The way we're going attack this is we're going to try to find the read page zero command, right?
      We know the answer to page zero.  Page zero 190UID.  We know what answer we should get even though it's encrypted.  But if you're working from the position of something you already know, attacking it is a lot easier.  Now, if an encrypted command is 10 bits long, a basic command is at least 10 bits long and encrypted to random noise then there's 1024 possibilities.  There's 16 correct answer only of which one will be the read page zero command.
      So, we could search and search and search.  When you send an invalid command, you get this unencrypted error response of F40289C.  And it has to be unencrypted because the idea that the reason that it's gone wrong in the normal use case is because something's gone wrong with the encryption.  If something's gone wrong with the encryption, you can't expect the tag to decrypt the error response.  It's an unencrypted response value and always the same number.  We can use that as a canary or as an Oracle to see if we're sending the right commands or not.  One way of attacking this  we're actually going to bit flip.  But one way of attacking this would be to send 1024, or up to 1024 encrypted commands, one after another.  Cycle through them.  Until we get something that isn't the error response.  Right?  The dumb brute force approach to doing this.  So, I'm going to have a drink, because it's been at least half an hour.
      I should do the demo.  This would be dumb, right?  Yeah.  You can obviously  this would be pointless.  But the reason it's pointless is because if you imagine what an encrypted command will look like, we know that F, you know, if the encrypted command is FEIJKLM  as individual bits, we know the F decrypts to 1 and K decrypts to zero because CM zero has to be a one for a read page command.  And K has to be the encryption  the inverse of that.  Or the decryption of K has to be the inverse of the decryption of F.  We know those parameters.  We know what they must decrypt to.  But equally, we know that the decryption of E, G, H and I must be the inverse of the encryption of J, L, M and N.  We don't know what the pattern is that we're dealing with, but we are using the same pattern each time.  So, what we do know is we don't have to care what J, L, M and N decrypt to, it could be a random pattern.  We could search E, G, H and I to decrypt that.  That's four bits out.  And reduces the odds, and we'll need to send 32 actual requests before we hit an actual success as opposed to 64.  So, we've halved the amount of work we need to do.  Honestly, it's cool.
      It's cryptocool, you know?  So, we have one valid recommand.  We just do that until one of them comes back with a different response to the unencrypted error.  Now we have one valid command.  And searching the others, we're going to bit flip that to find the others.  We don't have to do any transmission for the ERF, right?  It's much quicker.  So, if the one we find is EIGHIJKLM, then we could take that and imagine that decrypts to read page four inverted as the actual plain text.  Or the first half and the second half, when they're decrypted, must be the inverse of each other.
      Because it's a stream cipher, if you flip a bit in the encrypted version, it flips the same bit in the plain text version.  Which is where all the integrity and the insecurity of ciphers kind of fall down, right?  So, we could flip the first bit, E, for example, in this example.  And in this example it would flip it with a read inverted to a read command.  But if it was originally a read command, it would flip it to a read inverted command.  But in order to maintain the integrity, we have to flip the same bit in the inverted half.  So, bit 6 also has to be flipped.  But because of the nature of stream ciphers, if we flipped the bit in the cipher text and the same bit in the plain text, we can do the same on bit 6 as well.  If we flip bit 1, we also have to flip bit 6.  We end up with a valid read command.  Equally, we could flip a bit in the page bits.  So, if we had read in page 4 and we flipped bit 5, it would flip it to read inverted page 5 as long as we flipped bit 10 to maintain the integrity by flipping the same bit in the second half of the command.
      That's really neat.  So, basically given one actual read command that works in the encrypted form, we can flip it around until we get all 16 by basically just building a table.  It's really trivial.  And then what we can do is try every one of them out.  One of them must be read page zero like not inverted.  And that's the one we're looking for.  So, what we'll do is we'll go around a loop of trying each of the 16 possibilities.  Every time we'll reset the tag back to the same position with the same nonce to the same point of the PRNG.  And we'll test our guess.  And if it's right, we'll store the key stream that comes back.  And if it's wrong, we'll go around the loop and try to have one.  And each time we will reinitialize the tag.  Because we're working from the same position of the PRNG.
      Because we're using an emulated reader, replaying the same nonce, you get the same key stream back.  I repeat this enough times to hope that it gets boring so you just understand what I'm saying at this point.  Because I'm always fearful that I'm saying stuff and people are kind of going, but why!  Why does that work?  It's not actually that hard, honestly.  So, if we try our guess, right?  We're going to assume our guess is correct.  We have a 10bit encrypted command.  We don't know which read page or read page inverted command we have, but we're going to assume it's read page zero.  We can X all of that with the plain text of the read page zero command and that will retrieve the 10 bits of key stream that would be necessary if our guess was correct.
      When we've sent in, we get back the 32 bit response.  Not the error response, it's a valid read page respond of some description, and we can take that and assume that's page zero.  Which we know because it gets given to us in free in clear at the beginning of the handshake, right?  It's the UID.  So, we can X all whatever we get back with the UID.  That's the next 32 bits.  We have 42 bits of key stream if our guess is correct.  And if your guess is incorrect, we've got nonsense, right?  So, somehow we need to check in our 42 bits of key stream is correct or not.  What we do is we create a read page zero command that is 40 bits longing.  And we do that using that extended command definition that we had earlier.  The thing that we were going to attack.  So, a read page zero command would be 110000111 at very minimum followed by 11000 followed by 00011, et cetera.  Over and over and over again.  Up to the point where you stop sending these blocks.  So, we can make a 40bit version of the read page command with extreme integrity, right?  And all we do is X all that with the first 40 bits the key stream that we think we have generated to create an encrypted version of the command and reinitialize the tag with the nonce back to the same point again so it's using the same key stream.  And then we send the encrypted page zero command.  And we either get back the ever response, which means that if it decrypted, the integrity failed.  We weren't correct.  That wasn't the right command.  Or we get back a 32bit response which isn't the error response, it's essentially the encryption of page zero, UID.  That means that the first 40 bits of key stream must be correct and take the response and X with the UID to get back the next 30 bits.  Which basically gives us 72 bits of key stream from the point that the initialization.  And it being transmitted and completing the handshake.  Which means that we can send that nonce and challenge response value encrypted and know the pad that the commands and the responses have been X'd with.  We can do this.  We can basically read each page of the tag one by initializing the tag back to the same point and doing a different read page command each time.
      And the way we do the read page command is we create the plain text version, X it with the first ten bits, and then whatever comes back, the next 32 bits of key stream to get back the actual answer.  Which means that we can recover all eight pages of the tag.  And three of the pages involve the secrets that we need to know in order to be able to talk to any other tag in the system.
      So, I think it's a really cool attack.  So, I implemented it.  And the way I implemented it was I took our fiddler, made by aperture labs, which is major malfunction and Zach Franken.  And they have a nice bit of equipment.  If you have a proxmark, low and high frequency.  High frequency actually works.  Mainly because major malfunction wrote the code for that.  But low frequency stuff, it's not good.  It crashes.  Especially on HiTag2.  It doesn't work well.  But they made the RFIDler to plug the gap and wrote the code.  I went to the RFIDler GitHub page and they say that you can download the ID that you need in order to edit the firmware and download all of the firmware from the GitHub and start writing your own C.  Which is just straightforward C.  You can read through the code and go, this is quite understandable.  It's just programming.  Like you expect.  Normal kind of code.
      And when you actually want to like transmit or receive stuff over the RIF, you can hunt for the code can base and copy and paste the function calls and it works.  It's magic.  It took me longer to understand the maths in the paper than it did to write C to complement this stuff.  I've added a whole load of commands to RFIDler.  I've extended the WN command so you can literally pull out encrypted nonce in script values.  I've created a crack command to do the attack I just talked about.  A key stream command for the attack.  A reader command.  Once you have the key, you can read any tag in that system.  The clear store, it's about weaponizing this kind of stuff so you can have it hidden away with a battery powered thing rather than a laptop.  It's kind of neat.  To do the attack, you would do it along these lines.  But rather than talk it, let's do a demo.
      This is the bit that will fail miserably, I might add.  But anyway, let's try.  Right.  So, I've got a couple of terminal windows.  And a whole lot of windows underneath that you don't care about.  Right.  Okay.  So, let's top tip, if you're talking to EMF Camp, don't sit in the sun and drink beer all day.  It's not the answer.  Right.  So, this is an RFID, RFIDler and the tag 2 mode.  I'm going to put that into sniffpwn.  I'm going to clear it.  And then in store mode  I can't type.  Don't worry, I'll worry about that in a second.  I just set up another one over here.  I'm going to create one as a reader.  That's the one that I just kind of I'm hoping to configure there is going to be the eavesdropper.  It's really funny trying to type onehanded.
      But it's okay.  Honestly.  We have trust.  I can tell.  We have faith in the room.  This will all be supermarvelous.  Right.  Oh, okay.  Identify got a fake reader set up.  So, if we come back to this one, we want to sniff PWN, store.  Ah.  Okay.  You can see the store auth commands.   The reader is constantly emanating start auth using forthwith modulation mode over the field.  That means it's shouting out start auth, start auth because it's looking for a tag many times a second.  I'm going to introduce the tag and hoping we're going to manage to read it.  Hang on.  There.  Right.  So, that is  that is kind of reading it.  Most of the time.  And what we're capturing will be the encrypted nonce and encrypted response values assuming that that's working.  All right?
      So, let's stop that.  Am I in the right  yep.  Right.  So, let's see  oops.  Let's see what we've managed to capture.  List, L.  Ah.  There we go.  We've captured all of these encrypted nonces and response values.  You have seen FFFF  clears an error.  Ignore that.  There's no guarantee this would have been received clearly, right?  But we'll just trust that that's the case for the time being.
      So, if I now take  hang on.  I take the one that's the fake reader out of the way.  And I just have  I just have this RFIDler here and the tag.  Now what I'm going to do is place the tag on the antenna and we're going to try and crack it using one of those values.  Right?  So  where's my cursor?  I can take the last word if you like, I can take the first one of this page if you like, I can take any in between other than the FFFFs.  Just shout stop and I'll pick one at random.  Yeah?  That one there.  We will have that pair.  Okay.  Now, as a magician, clearly I will have forced you to the only one that works in this list.  But, honestly, we'll come back and try it again in a minute with a different one just to prove that I'm not using magic and mind control to trick this.
      Right.  So, what I'm doing is I'm going to run the crack command with this particular encrypted nonce and this particular encrypted value that goes with that nonce, right?  And it will get the UID off the tag itself.  It will hunt for a valid read page command.  It will then bit flip and try each of them out until it finds a read page zero command.  And then from there it will read the whole of the tag's banks of memory, right?
      The reason I tell you this before I press enter is when I tested this in my demo, I pushed enter and it happened to immediately  so, this was actually doing magic.  So, ha ha!  Brilliant.  Cannot get UI  oh.  Okay.  Right.  I just need to move  it's all very  see, this is the trouble with things that aren't software.  It's very, very sensitive.  Let's try that again.
      Such a big buildup for such a big error.  No, hang on a moment.  Hang on.  West ward, to take the piss.  Oh, god, for fuck's sake, man.  Don't keep this bit on the film, will ya?
      >> You're in the same window as the reader 
      KEV: I'm not, surely.  No, this should definitely be 1411, that should be 1421 down there.  That one's still reading in fairness.  Honestly that one is still reading.  I know you're being helpful.  Oh, for fuck's sake.  It's like not having two hands.  It really is like  like  this is accessibility errors.  Yes.  Or I could  you could just hold it there.  Let me just see if I can get  hang on.  I'll tell you what.  Let's kill the other one.  No longer  right.  It will work now.  I guarantee.
      Electronics is so easy.  I don't know what you were worried about.  Right.  So, anyway, we need to bring in command up here, okay?  And honestly, we will come back.  If this completes superquick, I will do it again with another pair so that you can see.  Oh, look at that.  It's actually searching for a read command.  It's gone off the side of the page.  Ah!  It found one.  And, oh, jeez.  That's actually a really good demo.  But there you go.
      [ Applause ] 
      And so, you can see that that is definitely a tag that I've read because page four says dead beef and five and six are my office phone number.  Feel free to ring me with all of your HiTag2 woes.
      But now we know that, we could do things like  we could put it into HiTag2 reader mode.  And we could use the key that we can pull out of pages 2 and 1.  So, that is the key.  And we run that.  We could then take our other tags which are hidden away down here.  See, we don't have to crack the other tags, we can just read them.  So, that one is just beef face.  That one is feed face.  And if we read the special tag 4, we know it's the pages 1 and is 2 are inaccessible.  Because it's been configured to not give you the contents of pages 1 and 2.  Which I'm now going to flip back to my slides and talk about very briefly.
      So, that was the demo.  Tag cloning.  If you know the key and they are not protecting the tags, you can just read the tags using the key that is provided.  And then once you've read the tag, you can write that to another tag.   The UID will be different, but it doesn't matter.  Because the UID is not used for any access control decisions.  It's only used as a randomization for the PRNG at the site of the crypto.  And you can potentially do that at a distance.  Although, anyone who wants to do it at a distance, get in touch.  We have money and we would like to help build something at a distance that works.
      So, I'll quickly go to my closing remarks.  This attack is amazing.  It's really cool.  Not because it attacks HiTag2 or you could use it to steal cars, but because it's a really neat way of abusing the protocol of the crypto and abusing something that people would generally think was secure to actually retrieve all of the secrets within the system.
      So, read the paper.  It's really clever.  Although it is hard to read.  But you might want to read through code instead.  But if they do protect the tag, then you can't use that attack.  Because you don't get pages one and two, you don't get the key.  That stops you being able to clone tags.  Instead you need attacks two or three from the same paper or attack four from the later paper.  Or five that comes from the early GPU attack, or six from the later GPU attack.  Attack two to cover the key takes two days to build a table.  A minute to get key stream off the tag, you need a valid tag, and then two minutes to search the table to find a matching key, right?
      So, if you've got a valid tag, attack 2 is really awesome.  If you haven't gotten a valid tag, use attack three, which only attacks the reader, five minutes to collect the values, but it takes 16 minutes on average to attack the tag.  On my Mac.  They think they can do it in 6 minutes, 60 minutes, I didn't bother optimizing that attack.  But getting the values from the reader, you can attack that really quickly and get the key.  Equally, attack four takes the same values, but you only need about 16 of them, maybe 1632 depending on how many  on your random luck or unluckiness.  Because it's a fast correlation attack, which is based on probability.  And the actual attack only takes 45 seconds.  It's really awesome.
      But you could just take two of those pairs of values and run them against attack five or six.  Attack five would take two hours on average on EC2 using a P2 X large, but run it against it on Amazon, 8GPUs, you can get it down to 15 minutes.  The same code will work over multiple hosts with multiple GPUs.  You could halve that if you had four posts, quarter with four hosts, et cetera.  And it all costs the same amount of money, $5.  Which is a very cheap way of attacking someone and stealing someone's BMW.  So, the point that I would like to make in my pent ultimate slide is we can learn lots from academics in the world of crypto.  So, in the world of like academia, they might not be the best hackers in the world.  We might think we know more than that because we're down and dirty and messing with tools and attacking networks and they are theorizing in their ivory towers, but when it comes to crypto, theorizing in ivory towers seems to be the ways to get the answers.  I think when they don't provide the tools, we can make our own tools.  And there must be a lot of stuff we haven't noticed yet because we are simply not looking there.  I think we should look more in the world of academia, implement more of their stuff and scare everybody with that.
      So, my final slide is simply the GitHub for Aperture Labs Limited.  You can find the RFID or RFIDler source.  It's got all four of the  it's got the first four attacks and all of the slides to explain it.  And you can find my contact so you can get in touch if you wish.  Thank you very much.
      [ Applause ]
      Oh, we'll be drinking more.  42.  The mic's not on, can you turn on the mic for the audience, please?  Try talking.  It might work.  Just shout and I'll repeat it.  Oh, oh!
      AUDIENCE: [ Away from microphone ]
      KEV: Yeah, check.
      AUDIENCE: So, obviously stream cipher is based on NSFR are not exactly state of the art.  But could we salvage a system like this by taking a page out of the BluRay book and having each tag have multiple, say, 64 keys on it?  64 different keys on it?  So, when you actually steal one of the cars, you can compromise those 64 keys, but somehow by clever use of the other keys you're able to still keep the integrity of that entire system?
      >> AUDIENCE MEMBER:  I've not looked at that attack.  I think adding more keys would give me more things to attack.  I would end up with a bank of 64 keys in the dictionary and probably use that to attack the rest of the system and clone the rest of the tags.  You need integrity protection of the keys.  So, that's what this tag system doesn't provide.  And what one time pads and stream stuff doesn't provide integrity.  But we have GCM and the authenticate encryption.  So, yeah.  Go on, Graham.  You clearly were going to  no.
      >> Okay.  You're probably going to have to be the next one.  We have to set up for the next speaker.
      AUDIENCE: Would all of that bit flipping have not worked if they put a check sum instead or CRC?
      KEV: No.
      AUDIENCE: Doesn't help at all?
      KEV: No, doesn't solve the problem at all.  Because at that point we have the pad that we're attacking.  So, it won't expand the space we searched, but it wouldn't actually solve the problem.
      >> All right.  I think that's all we have time for.  Thank you very much, Kev.
      KEV: Thank you.
      [ Applause ]
      >> Buy me a pint.
      >> Buy him a pint.
      [Break]

